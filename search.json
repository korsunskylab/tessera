[{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"libs","dir":"Articles","previous_headings":"","what":"Libs","title":"Quickstart: Using Tessera on a Single Sample","text":"","code":"suppressPackageStartupMessages({     library(tessera)      ## Downstream analysis in Seurat V5     library(Seurat)      ## Plotting functions      ## Not imported by Tessera     library(ggplot2)     library(ggthemes)     library(viridis)     library(patchwork) })  fig.size <- function(h, w) {     options(repr.plot.height = h, repr.plot.width = w) }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Quickstart: Using Tessera on a Single Sample","text":"Small sample MERFISH dataset Chen et al: https://www.biorxiv.org/content/10.1101/2023.04.04.535379v1.abstract  coarse grained cell types predefined , help interpret tiles get .","code":"data('tessera_warmup') counts = tessera_warmup$counts meta_data = tessera_warmup$meta_data meta_vars_include = c('type') fig.size(8, 8) ggplot() +      geom_point(data = meta_data, aes(X, Y, color = type)) +      theme_void() +      scale_color_tableau() +      coord_sf(expand = FALSE) +      NULL table(meta_data$type) #>  #> Epithelial Fibroblast Lymphocyte       Mast    Myeloid     Plasma   Vascular  #>        634        588        829         18        491        206        411"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"get-tiles","dir":"Articles","previous_headings":"","what":"Get Tiles","title":"Quickstart: Using Tessera on a Single Sample","text":"Run Tessera algorithm get tiles one function. result returns two structures: dmt: cell-level information. aggs: tile-level information. two tied together dmt$pts$agg_id","code":"res = GetTiles(     X = meta_data$X,      Y = meta_data$Y,      counts = counts,      meta_data = meta_data,      meta_vars_include = meta_vars_include, ) #> Warning in GetTiles.default(X = meta_data$X, Y = meta_data$Y, counts = counts, #> : No embeddings provided. Calculating embeddings using PCA. #> Warning in GetTiles.default(X = meta_data$X, Y = meta_data$Y, counts = counts, #> : No value for group.by provided. Analyzing as a single sample. dmt = res$dmt aggs = res$aggs fig.size(10, 30) purrr::map(1:3, function(i) {     ggplot(cbind(aggs$meta_data, val=aggs$pcs[, i])) +          geom_sf(aes(geometry = shape, fill = val)) +          theme_void(base_size = 16) +          coord_sf(expand = FALSE) +          scale_fill_gradient2_tableau() +          guides(color = 'none') +          labs(title = paste0('PC', i)) +          NULL  }) %>%      purrr::reduce(`|`)"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"cluster-and-label-tiles","dir":"Articles","previous_headings":"","what":"Cluster and label tiles","title":"Quickstart: Using Tessera on a Single Sample","text":"Let’s treat aggregate unit analysis. typical steps Seurat clustering. Let’s see aggregate clusters UMAP physical space.","code":"obj = Seurat::CreateSeuratObject(     counts = aggs$counts,      meta.data = tibble::column_to_rownames(data.frame(dplyr::select(aggs$meta_data, -shape)), 'id') )  ## Seurat doesn't do sf shapes well  obj@meta.data$shape = aggs$meta_data$shape  ## Represent each tile as the mean PC embeddings of all its cells  ## NOTE: this tends to produce more biologically meaningful results than pooling gene counts per tile  rownames(aggs$pcs) = colnames(obj) obj[['pca']] = Seurat::CreateDimReducObject(embeddings = aggs$pcs, loadings = dmt$udv_cells$loadings, key = 'pca_', assay = Seurat::DefaultAssay(obj)) .verbose = FALSE obj = obj %>%      NormalizeData(normalization.method = 'LogNormalize', scale.factor = median(obj@meta.data$nCount_RNA), verbose = .verbose) %>%      RunUMAP(verbose = .verbose, dims = 1:10, reduction = 'pca') %>%      Seurat::FindNeighbors(features = 1:10, reduction = 'pca', verbose = .verbose) %>%      Seurat::FindClusters(verbose = .verbose, resolution = c(2)) #> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation' #> This message will be shown once per session p1 = DimPlot(obj, reduction = 'umap', group.by = 'seurat_clusters') + scale_color_tableau('Classic 10')  p2 = ggplot(obj@meta.data) +      geom_sf(aes(geometry = shape, fill = seurat_clusters)) +      theme_void(base_size = 16) +      coord_sf(expand = FALSE) +      scale_fill_tableau('Classic 10') +      NULL   fig.size(6, 12) (p1 | p2) + plot_layout(widths = c(1, 1))"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"transfer-agg-information-to-cells","dir":"Articles","previous_headings":"","what":"Transfer agg information to cells","title":"Quickstart: Using Tessera on a Single Sample","text":"Let’s look composition spatial clusters.  can also query genes space usually cells.","code":"dmt$pts$spatial_cluster = obj@meta.data$seurat_clusters[dmt$pts$agg_id] p1 = ggplot() +      geom_sf(data = obj@meta.data, aes(geometry = shape), fill = NA) +      geom_point(data = dmt$pts, aes(X, Y, color = type)) +      scale_color_tableau() +      theme_void() +      coord_sf(expand = FALSE) +      NULL p2 = ggplot() +      geom_sf(data = obj@meta.data, aes(geometry = shape, fill = seurat_clusters), alpha = .2) +      geom_point(data = dmt$pts, aes(X, Y, color = spatial_cluster)) +      scale_color_tableau('Classic 10') +      scale_fill_tableau('Classic 10') +      theme_void() +      guides(fill = 'none') +      coord_sf(expand = FALSE) +      NULL fig.size(8, 20) p1 | p2 fig.size(8, 10) dmt$pts %>%      with(table(type, spatial_cluster)) %>%      prop.table(2) %>%      data.table() %>%      ggplot(aes(spatial_cluster, 100 * N, fill = type)) +          geom_bar(stat = 'identity', position = position_stack()) +          scale_fill_tableau() +          theme_bw(base_size = 20) +          labs(y = '% of spatial cluster', fill = 'cell type') +          NULL feature = 'MKI67' ## dividing cells  # feature = 'CD3E' ## T cells   fig.size(8, 10) ggplot() +      geom_sf(data = cbind(obj@meta.data, FetchData(obj, feature)), aes(geometry = shape, fill = !!sym(feature))) +      scale_fill_gradient(low = 'white', high = '#832424') +      theme_void() +      coord_sf(expand = FALSE) +      NULL"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_basic.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Quickstart: Using Tessera on a Single Sample","text":"","code":"sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] purrr_1.1.0        future_1.67.0      patchwork_1.3.2    viridis_0.6.5      #>  [5] viridisLite_0.4.2  ggthemes_5.1.0     ggplot2_3.5.2      Seurat_5.3.0       #>  [9] SeuratObject_5.2.0 sp_2.2-0           tessera_0.1.5      Rcpp_1.1.0         #> [13] data.table_1.17.8  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3     jsonlite_2.0.0         magrittr_2.0.3         #>   [4] spatstat.utils_3.1-5   farver_2.1.2           rmarkdown_2.29         #>   [7] fs_1.6.6               ragg_1.4.0             vctrs_0.6.5            #>  [10] ROCR_1.0-11            spatstat.explore_3.5-2 htmltools_0.5.8.1      #>  [13] sass_0.4.10            sctransform_0.4.2      parallelly_1.45.1      #>  [16] KernSmooth_2.23-26     bslib_0.9.0            htmlwidgets_1.6.4      #>  [19] desc_1.4.3             ica_1.0-3              plyr_1.8.9             #>  [22] plotly_4.11.0          zoo_1.8-14             cachem_1.1.0           #>  [25] igraph_2.1.4           mime_0.13              lifecycle_1.0.4        #>  [28] pkgconfig_2.0.3        Matrix_1.7-3           R6_2.6.1               #>  [31] fastmap_1.2.0          magic_1.6-1            fitdistrplus_1.2-4     #>  [34] shiny_1.11.1           digest_0.6.37          furrr_0.3.1            #>  [37] tensor_1.5.1           RSpectra_0.16-2        irlba_2.3.5.1          #>  [40] textshaping_1.0.1      labeling_0.4.3         progressr_0.15.1       #>  [43] spatstat.sparse_3.1-0  httr_1.4.7             polyclip_1.10-7        #>  [46] abind_1.4-8            compiler_4.5.1         proxy_0.4-27           #>  [49] withr_3.0.2            DBI_1.2.3              fastDummies_1.7.5      #>  [52] MASS_7.3-65            classInt_0.4-11        tools_4.5.1            #>  [55] units_0.8-7            lmtest_0.9-40          httpuv_1.6.16          #>  [58] future.apply_1.20.0    goftest_1.2-3          glue_1.8.0             #>  [61] nlme_3.1-168           promises_1.3.3         grid_4.5.1             #>  [64] sf_1.0-21              Rtsne_0.17             cluster_2.1.8.1        #>  [67] reshape2_1.4.4         generics_0.1.4         gtable_0.3.6           #>  [70] spatstat.data_3.1-8    class_7.3-23           tidyr_1.3.1            #>  [73] spatstat.geom_3.5-0    RcppAnnoy_0.0.22       ggrepel_0.9.6          #>  [76] RANN_2.6.2             pillar_1.11.0          stringr_1.5.1          #>  [79] spam_2.11-1            RcppHNSW_0.6.0         later_1.4.4            #>  [82] splines_4.5.1          dplyr_1.1.4            lattice_0.22-7         #>  [85] survival_3.8-3         deldir_2.0-4           tidyselect_1.2.1       #>  [88] miniUI_0.1.2           pbapply_1.7-4          knitr_1.50             #>  [91] gridExtra_2.3          scattermore_1.2        xfun_0.53              #>  [94] matrixStats_1.5.0      stringi_1.8.7          lazyeval_0.2.2         #>  [97] yaml_2.3.10            evaluate_1.0.5         codetools_0.2-20       #> [100] tibble_3.3.0           cli_3.6.5              uwot_0.2.3             #> [103] geometry_0.5.2         xtable_1.8-4           reticulate_1.43.0      #> [106] systemfonts_1.2.3      jquerylib_0.1.4        globals_0.18.0         #> [109] spatstat.random_3.4-1  png_0.1-8              spatstat.univar_3.1-4  #> [112] parallel_4.5.1         pkgdown_2.1.3          dotCall64_1.2          #> [115] mclust_6.1.1           listenv_0.9.1          scales_1.4.0           #> [118] e1071_1.7-16           ggridges_0.5.7         rlang_1.1.6            #> [121] cowplot_1.2.0"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"notebook walkthrough steps Tessera, want get familiar components.","code":""},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"libs","dir":"Articles","previous_headings":"","what":"Libs","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"suppressPackageStartupMessages({     library(tessera)      ## Plotting functions      ## Not imported by Tessera     library(ggplot2)     library(ggthemes)     library(viridis)     library(patchwork) })  fig.size <- function(h, w) {     options(repr.plot.height = h, repr.plot.width = w) }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"parameters","dir":"Articles","previous_headings":"","what":"Parameters","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"verbose = TRUE show_plots = TRUE  ###### STEP 0 ###### npcs = 10 ## Graph pruning prune_thresh_quantile = 0.95 prune_min_cells = 10   ###### STEP 1: GRADIENTS ###### smooth_distance = c('none', 'euclidean', 'projected', 'constant')[3]  smooth_similarity = c('none', 'euclidean', 'projected', 'constant')[3]    ###### STEP 2: DMT ###### ## ... no options   ###### STEP 3: AGGREGATION ###### max_npts = 50 min_npts = 5 alpha = 1 ## 0.2 = conservative merging, 2 = liberal merging"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"Small sample MERFISH dataset Chen et al: https://www.biorxiv.org/content/10.1101/2023.04.04.535379v1.abstract  coarse fine grained cell types predefined , help interpret tiles get .","code":"data('tessera_warmup') counts = tessera_warmup$counts meta_data = tessera_warmup$meta_data meta_vars_include = c('type') fig.size(8, 8) ggplot() +      geom_point(data = meta_data, aes(X, Y, color = type)) +      theme_void() +      scale_color_tableau() +      coord_sf(expand = FALSE) +      NULL table(meta_data$type) #>  #> Epithelial Fibroblast Lymphocyte       Mast    Myeloid     Plasma   Vascular  #>        634        588        829         18        491        206        411"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"prepare","dir":"Articles","previous_headings":"Data","what":"prepare","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"dmt = init_data(meta_data$X, meta_data$Y, counts, meta_data, meta_vars_include) dmt = prune_graph(dmt, thresh_quantile = prune_thresh_quantile, mincells = prune_min_cells) dmt = add_exterior_triangles(dmt) fig.size(15, 15) # fig.size(20, 20)  if (show_plots) {         ggplot() +               # ## big data          # geom_point(data = dmt$pts, aes(X, Y), shape = '.', alpha = .1) +          # geom_segment(data = dmt$edges[boundary == TRUE], aes(x = x0_pt, y = y0_pt, xend = x1_pt, yend = y1_pt), color = 'red', lwd = .2) +               ## small data          geom_segment(data = dmt$edges, aes(x = x0_pt, y = y0_pt, xend = x1_pt, yend = y1_pt), color = 'black', lwd = .2) +          geom_segment(data = dmt$edges[boundary == TRUE], aes(x = x0_pt, y = y0_pt, xend = x1_pt, yend = y1_pt), color = 'red', lwd = .2) +          geom_point(data = dmt$pts, aes(X, Y), size = .5) +               theme_void(base_size = 20) +          coord_cartesian(expand = FALSE) +          labs(title = 'Pruned adjacency graph') +          NULL }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"pca","dir":"Articles","previous_headings":"Data","what":"pca","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"dmt$udv_cells = do_pca(dmt$counts, npcs)"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"step-1-compute-gradients-on-all-data-structures","dir":"Articles","previous_headings":"","what":"Step 1: compute gradients on all data structures","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"field = compute_gradients(dmt, smooth_distance, smooth_similarity) field = compress_gradients_svd(field) if (show_plots) {          len_plot_constant = .8     fig.size(15, 15)     # fig.size(20, 20)     ggplot() +          geom_point(data = dmt$pts, aes(X, Y), size = .5) +          geom_segment(data = dmt$edges[boundary == TRUE, ], aes(x = x0_pt, y = y0_pt, xend = x1_pt, yend = y1_pt), color = 'red') +               ## Triangle Gradients         geom_segment(             data = data.table(dmt$tris, field$tris_svd),              aes(                 x=X-len_plot_constant*(len_grad+len_ortho)*dx_ortho,                  y=Y-len_plot_constant*(len_grad+len_ortho)*dy_ortho,                  xend=X+len_plot_constant*(len_grad+len_ortho)*dx_ortho,                  yend=Y+len_plot_constant*(len_grad+len_ortho)*dy_ortho             ),              linewidth = .4, alpha = 1,              color = 'blue'         ) +               theme_void() +          coord_fixed(expand = FALSE) +          NULL }"},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"compute-f","dir":"Articles","previous_headings":"Step 2: DMT","what":"compute f","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"dmt = dmt_set_f(dmt, field) if (show_plots) {         ntri = max(which(dmt$tris$external == FALSE))     i = Matrix::t(dmt$tri_to_pt[1:ntri, ])@i+1     plt_df = data.table(         X = dmt$pts$X[i],         Y = dmt$pts$Y[i],         f = rep(dmt$tris$f[1:ntri], each = 3)     )[         , id := rep(1:ntri, each = 3)     ][]               fig.size(15, 15)     ggplot() +          geom_polygon(data = plt_df, aes(X, Y, group = id, fill = f, color = f)) +          theme_void() +          coord_fixed(expand = FALSE) +          scale_fill_viridis() +          scale_color_viridis() +          NULL }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"forests","dir":"Articles","previous_headings":"Step 2: DMT","what":"forests","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"dmt$prim = do_primary_forest(dmt) dmt$dual = do_dual_forest(dmt) if (show_plots) {         fig.size(15, 15)     ggplot() +              ## primary forest         geom_point(data = dmt$tris[dmt$dual$maxima, ], aes(X, Y), color = 'blue', size = 2) +          geom_segment(data = dmt$dual$edges, aes(x=x0, y=y0, xend=x1, yend=y1), color = 'blue') +           ## primary forest         geom_point(data = dmt$pts[dmt$prim$minima, ], aes(X, Y), color = 'red', size = 2) +          geom_segment(data = dmt$prim$edges, aes(x=x0, y=y0, xend=x1, yend=y1), color = 'red') +               theme_void() +          coord_cartesian(expand = FALSE) +          NULL }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"extract-epaths","dir":"Articles","previous_headings":"Step 2: DMT","what":"extract epaths","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"DMT, separatrix (blue) primary forest connecting points (red).","code":"dmt$e_sep = dmt_get_separatrices(dmt) if (show_plots) {         fig.size(15, 15)     ggplot() +               geom_segment(data = dmt$edges[dmt$e_sep, ], aes(x = x0_tri, y = y0_tri, xend = x1_tri, yend = y1_tri), lwd = 1, color = 'blue') +          geom_segment(data = dmt$edges[boundary == TRUE], aes(x = x0_pt, y = y0_pt, xend = x1_pt, yend = y1_pt), color = 'blue', lwd = 1) +               ## primary forest         geom_point(data = dmt$pts[dmt$prim$minima, ], aes(X, Y), color = 'red', size = 2) +          geom_segment(data = dmt$prim$edges, aes(x=x0, y=y0, xend=x1, yend=y1), color = 'red') +               theme_void() +          coord_cartesian(expand = FALSE) +          NULL }"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"extract-tiles","dir":"Articles","previous_headings":"Step 2: DMT","what":"extract tiles","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"dmt = dmt_assign_tiles(dmt) aggs = dmt_init_tiles(dmt) if (show_plots) {         set.seed(2)     fig.size(15, 20)     ggplot() +          geom_sf(data = aggs$meta_data$shape) +          # geom_point(data = dmt$pts, aes(X, Y, color = factor(agg_id, sample(nrow(aggs$meta_data)))), size = 1) +          # scale_color_tableau() +          theme_void() +          coord_sf(expand = FALSE) +          # coord_cartesian(expand = FALSE) +          guides(color = 'none') +                   NULL  } if (show_plots) {         set.seed(2)     fig.size(15, 20)     ggplot() +          geom_sf(data = aggs$meta_data$shape) +          geom_point(data = dmt$pts, aes(X, Y, color = type)) +          theme_void() +          coord_sf(expand = FALSE) +          scale_color_tableau() +          guides(color = 'none') +          NULL  }"},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"merge-main","dir":"Articles","previous_headings":"Step 3: Aggregation","what":"Merge main","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"First, merge similar aggregates nearby.","code":"aggs = init_scores(aggs, agg_mode=2, alpha=alpha, max_npts=max_npts) aggs = merge_aggs(aggs, agg_mode=2, max_npts=max_npts) dmt = update_dmt_aggid(dmt, aggs) aggs = update_agg_shapes(dmt, aggs)"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"merge-small-outliers","dir":"Articles","previous_headings":"Step 3: Aggregation","what":"Merge small outliers","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"go ahead merge small clusters smaller ","code":"aggs = init_scores(aggs, agg_mode=3, alpha=alpha, min_npts=min_npts) aggs = merge_aggs(aggs, agg_mode=3, min_npts=min_npts) dmt = update_dmt_aggid(dmt, aggs) aggs = update_agg_shapes(dmt, aggs)"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"final-tiles","dir":"Articles","previous_headings":"Step 3: Aggregation","what":"Final tiles","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"fig.size(10, 30) if (show_plots) {      purrr::map(1:3, function(i) {         ggplot(cbind(aggs$meta_data, val=aggs$pcs[, i])) +              geom_sf(aes(geometry = shape, fill = val)) +              theme_void(base_size = 16) +              coord_sf(expand = FALSE) +              scale_fill_gradient2_tableau() +              guides(color = 'none') +              labs(title = paste0('PC', i)) +              NULL      }) %>%          purrr::reduce(`|`) }"},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"aggregates","dir":"Articles","previous_headings":"Results","what":"Aggregates","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"primary output tiles. tile row meta_data table: npts denotes number cells tile. also pooled gene counts, differential gene expression analysis. PCA embeddings tiles. rest fields internal algorithm can ignored.","code":"head(aggs$meta_data) #>       id        X        Y  npts                          shape      area #>    <int>    <num>    <num> <num>                 <sfc_GEOMETRY>     <num> #> 1:     1 5578.221 10074.77    39 POLYGON ((5598.428 10051.98... 2624.2586 #> 2:     2 5523.750 10051.83    43 POLYGON ((5513.932 10008.66... 2718.7684 #> 3:     3 5550.940 10103.57    36 POLYGON ((5572.969 10116.07... 2405.4418 #> 4:     4 5577.735 10114.87     8 POLYGON ((5572.969 10116.07...  651.2121 #> 5:     5 5565.044 10019.62    41 POLYGON ((5614.379 10006.3,... 2292.7048 #> 6:     6 5609.770 10088.19    14 POLYGON ((5631.174 10097.96...  998.8177 #>    perimeter #>        <num> #> 1:  428.9675 #> 2:  305.5045 #> 3:  281.2410 #> 4:  139.6050 #> 5:  317.2784 #> 6:  189.5318 aggs$counts[1:5, 1:5] #> 5 x 5 sparse Matrix of class \"dgCMatrix\" #>       1 2 3 4 5 #> ACE   1 2 2 1 1 #> ACKR1 . . 1 . . #> ACKR2 1 . . . . #> ACKR3 . . 1 . 1 #> ACKR4 . 2 . . . head(aggs$pcs) #>            PC1        PC2         PC3        PC4       PC5         PC6 #> [1,] 0.6254406  1.0283725  0.83291401 -1.8056105 0.7110007 -0.03214636 #> [2,] 0.5616029 -0.2555397  0.42623300 -1.0095698 0.5037828  0.40149483 #> [3,] 1.2233199 -0.4752796  1.14695964 -0.6278043 0.8871260 -0.06488547 #> [4,] 1.3895474 -1.5392132  4.44642532  1.3297266 1.2699776 -0.95557892 #> [5,] 1.5045535  0.5159752  1.64675922 -0.7636852 0.5256705 -0.32880955 #> [6,] 0.2784406  3.2868679 -0.09497244  1.6126753 0.8367197  0.04392108 #>             PC7         PC8        PC9        PC10 #> [1,] -0.5800751 -0.63061009 -0.3744196 -0.09222084 #> [2,] -1.2530492 -0.02118518  0.4606577  0.83385141 #> [3,] -0.9724555 -0.63276613 -0.1425679  0.22528892 #> [4,] -0.3429736 -0.14724817  1.1103697  0.34060965 #> [5,]  0.2752555 -0.43487561  0.2355197  0.28518495 #> [6,] -1.0273620  0.06585632 -0.4865450  0.10742521 setdiff(names(aggs), c('pcs', 'meta_data', 'counts')) #> [1] \"edges\"      \"pcs_merged\" \"d_mu\"       \"d_sig\"      \"aggmap\""},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"points","dir":"Articles","previous_headings":"Results","what":"Points","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"also keep information cells dmt. fields duplicates inputs intermediate results. important fields keep analyses : ORIG_ID: index cell input data. cells get filtered outliers, input cells get assigned aggregate. agg_id: index tile aggs data structures .","code":"names(dmt) #> [1] \"pts\"       \"tris\"      \"edges\"     \"tri_to_pt\" \"counts\"    \"udv_cells\" #> [7] \"prim\"      \"dual\"      \"e_sep\" head(dmt$pts[, .(ORIG_ID, agg_id)]) #>    ORIG_ID agg_id #>      <int>  <int> #> 1:       1      1 #> 2:       2      2 #> 3:       3      3 #> 4:       4      4 #> 5:       5      5 #> 6:       6      5"},{"path":"https://korsunskylab.github.io/tessera/articles/vignette_stepthrough.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Walkthrough: Tessera Algorithm Step-by-Step","text":"","code":"sessionInfo() #> R version 4.5.1 (2025-06-13) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] patchwork_1.3.2   viridis_0.6.5     viridisLite_0.4.2 ggthemes_5.1.0    #> [5] ggplot2_3.5.2     tessera_0.1.5     Rcpp_1.1.0        data.table_1.17.8 #>  #> loaded via a namespace (and not attached): #>  [1] gtable_0.3.6       xfun_0.53          bslib_0.9.0        htmlwidgets_1.6.4  #>  [5] lattice_0.22-7     vctrs_0.6.5        tools_4.5.1        generics_0.1.4     #>  [9] parallel_4.5.1     tibble_3.3.0       proxy_0.4-27       pkgconfig_2.0.3    #> [13] Matrix_1.7-3       KernSmooth_2.23-26 RColorBrewer_1.1-3 desc_1.4.3         #> [17] lifecycle_1.0.4    compiler_4.5.1     farver_2.1.2       stringr_1.5.1      #> [21] textshaping_1.0.1  codetools_0.2-20   htmltools_0.5.8.1  class_7.3-23       #> [25] sass_0.4.10        yaml_2.3.10        pkgdown_2.1.3      pillar_1.11.0      #> [29] furrr_0.3.1        jquerylib_0.1.4    classInt_0.4-11    cachem_1.1.0       #> [33] abind_1.4-8        mclust_6.1.1       RSpectra_0.16-2    parallelly_1.45.1  #> [37] tidyselect_1.2.1   digest_0.6.37      stringi_1.8.7      future_1.67.0      #> [41] sf_1.0-21          dplyr_1.1.4        purrr_1.1.0        listenv_0.9.1      #> [45] labeling_0.4.3     magic_1.6-1        fastmap_1.2.0      grid_4.5.1         #> [49] cli_3.6.5          magrittr_2.0.3     e1071_1.7-16       withr_3.0.2        #> [53] scales_1.4.0       rmarkdown_2.29     globals_0.18.0     igraph_2.1.4       #> [57] gridExtra_2.3      ragg_1.4.0         evaluate_1.0.5     knitr_1.50         #> [61] geometry_0.5.2     rlang_1.1.6        glue_1.8.0         DBI_1.2.3          #> [65] jsonlite_2.0.0     R6_2.6.1           systemfonts_1.2.3  fs_1.6.6           #> [69] units_0.8-7"},{"path":"https://korsunskylab.github.io/tessera/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ilya Korsunsky. Maintainer, author. Daniel Stein. Author.","code":""},{"path":"https://korsunskylab.github.io/tessera/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Stein DJ, Tran M, Korsunsky (2025). “Accurate tiling spatial single-cell data Tessera.” bioRxiv. doi:10.1101/2025.01.17.633630, https://www.biorxiv.org/content/early/2025/01/22/2025.01.17.633630.full.pdf, https://www.biorxiv.org/content/early/2025/01/22/2025.01.17.633630.","code":"@Article{,   author = {Daniel Jiang Stein and Miles Tran and Ilya Korsunsky},   title = {Accurate tiling of spatial single-cell data with Tessera},   year = {2025},   doi = {10.1101/2025.01.17.633630},   publisher = {Cold Spring Harbor Laboratory},   abstract = {Single-cell spatial transcriptomics reveals how cells organize in healthy and diseased tissues. From these data, tissue segmentation analysis defines discrete compartments that organize cells into functional multicellular units. Existing methods for automated tissue segmentation rely on spatial smoothing to define spatially coherent regions but often blur the boundaries between adjacent tissue compartments. We describe Tessera, an algorithm that approaches tissue segmentation through a novel approach, dividing the tissue into small multicellular tiles whose edges track with natural tissue boundaries. Tessera achieves this by incorporating successful tools from edge-preserving smoothing, topological data analysis, and morphology-aware agglomerative spatial clustering. We show that Tessera identifies a range of known anatomical structures, in healthy mouse brain and human lymph nodes, and novel disease-associated niches, in human brain and in lung cancer. Tessera is a general-purpose tool that returns spatially coherent spatial structures with accurate boundaries across a range of spatial transcriptomics and proteomics technologies.Competing Interest StatementThe authors have declared no competing interest.},   url = {https://www.biorxiv.org/content/early/2025/01/22/2025.01.17.633630},   eprint = {https://www.biorxiv.org/content/early/2025/01/22/2025.01.17.633630.full.pdf},   journal = {bioRxiv}, }"},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"tessera","dir":"","previous_headings":"","what":"Accurate Tiling of Spatial Single-Cell Data","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Accurate tiling spatial single-cell data Tessera Tessera algorithm segmenting single-cell resolution spatial omics data small multicellular tiles whose edges track natural tissue boundaries. tiles can used downstream analysis label define tissue regions across samples. Check manuscript bioRxiv additional details.","code":""},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Tessera algorithm takes input single cells (pixels) spatial coordinates cell embeddings (transcript counts) cell. output segmentation adjacent cells tiles user-controlled size parameter. Boundaries tiles align cell composition gene expression change within tissue. Segmentation using Tessera algorithm four main steps: Constructing inputs: triangle mesh constructed using Delauney triangulation pruned eliminate long edges. transcript counts provided cell instead embeddings, cell embeddings computed using principal component analysis (PCA). Gradient estimation: Gradients calculated vertex considering difference cell embeddings cell neighbors mesh. gradients smoothed using anisotropic bilateral filtering, gradients defined edges triangles mesh averaging vertices edge triangle contains. Tissue segmentation using discrete Morse theory (DMT): scalar field defined taking magnitude total gradient vertex, edge, triangle. DMT-based segmentation performed constructing maximum spanning forest triangles minimum spanning forest vertices. Separatrices partition cells tiles homogeneous composition defined tracing paths critical points, specifically saddle edges maximum triangles. Hierarchical agglomeration: Tiles DMT-based segmentation merged using single-linkage agglomerative clustering obtain tiles containing number cells user-provided minimum maximum value. Pairs adjacent tiles scored according transcriptional similarity, compactness shape merging, number cells, order prioritize favorable merges agglomerative clustering step.","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"os-requirements","dir":"","previous_headings":"System Requirements","what":"OS Requirements","title":"Accurate Tiling of Spatial Single-Cell Data","text":"tessera supperted macOS Linux. package tested following systems: macOS: Sonoma (14.6.1) Linux: CentOS 7 (7.9.2009)","code":""},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"r-dependencies","dir":"","previous_headings":"System Requirements","what":"R Dependencies","title":"Accurate Tiling of Spatial Single-Cell Data","text":"tessera tested R versions >= 4.3. Please consult DESCRIPTION file details required R packages, including Rcpp R C++ integraion.","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"install-from-github","dir":"","previous_headings":"Installation","what":"Install from GitHub","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Open R run: install dependencies CRAN, can slow fails systems. Instead, recommended install dependencies manually using conda/mamba (see ).","code":"devtools::install_github('korsunskylab/tessera')"},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"manually-install-dependencies-with-condamamba-recommended","dir":"","previous_headings":"Installation","what":"Manually install dependencies with conda/mamba (recommended)","title":"Accurate Tiling of Spatial Single-Cell Data","text":"command line: Next, R console:","code":"mamba create -n tessera_env mamba activate tessera_env  ## If using macOS with Apple Silicon: # conda config --env --set subdir osx-64  # Install required dependencies (~1 min) mamba install -c conda-forge r-essentials r-rcpp r-rcpparmadillo r-bh r-devtools \\ r-tidyverse r-matrix r-rlang r-r.utils r-sf r-igraph r-furrr r-future r-data.table \\ r-geometry r-mclust r-rspectra r-magrittr r-harmony  # Optionally install Seurat and additional packages to run vignettes (~15 sec) mamba install -c conda-forge r-seurat r-ggthemes r-patchwork r-viridis jupyterlab r-irkernel devtools::install_github('korsunskylab/tessera', dependencies = FALSE)  # ~1 min"},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"standalone-mode","dir":"","previous_headings":"Quick Start","what":"Standalone Mode","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Check vignette(\"vignette_basic\") quick start tutorial demonstrates using tessera standalone mode single sample. basic usage follows:","code":"res = GetTiles(     X = meta_data$X,         # Vector of cell spatial coordinates     Y = meta_data$Y,         # Vector of cell spatial coordinates     counts = counts,         # Gene-by-cell matrix of transcript counts      embeddings = embeddings, # (Optional) Cell-by-embedding matrix of pre-computed cell embeddings. If missing, embeddings are calculated using PCA.     meta_data = meta_data,   # (Optional) Additional cell meta data     meta_vars_include = meta_vars_include, # (Optional) Cell meta data to include in output      group.by = 'sample_id',  # (Optional) Name of meta_data column that provides sample IDs. If missing, treated as a single sample.      # Additional Tessera algorithm parameters     prune_thresh_quantile = 0.99, prune_min_cells = 1, # Control pruning of long edges and disconnected cells     max_npts = 50, min_npts = 5,                       # Control size of Tessera tiles     ...                       ) dmt = res$dmt                # Mesh data structures with results from segmentation aggs = res$aggs              # Tiles resulting from DMT-based segmentation and agglomeration"},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"seurat-objects-multi-sample","dir":"","previous_headings":"Quick Start","what":"Seurat Objects (Multi-sample)","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Tessera can also applied directly Seurat object containing single cells spatial coordinates. GetTiles function can use cell embeddings already pre-computed (integrated, multiple samples). default, output pair Seurat objects: 1) single-cell Seurat object updated tile assignments cell, 2) Seurat object entry represents individual Tessera tile.","code":"options(future.globals.maxSize= 4*1024^3)   # For larger datasets, the memory allowance may need to be increased for parallelization future::plan(future::multicore)             # Parallelize over multiple samples (if doing multi-sample analysis) res = GetTiles(     obj,        # Single-cell Seurat object     'spatial',  # Name of dimesional reduction where x/y coordinates are stored      embeddings = 'harmony',  # (Optional) Name of dimensional reduction where pre-computed single-cell embeddings are stored     group.by = 'sample_id',  # (Optional) Name of meta.data column that provides sample IDs. If missing, treated as a single sample.      # Additional Tessera algorithm parameters     prune_thresh_quantile = 0.99, prune_min_cells = 1, # Control pruning of long edges and disconnected cells     max_npts = 50, min_npts = 5,                       # Control size of Tessera tiles     ... ) obj = res$obj                # Seurat object of single-cells (with cell-to-tile mapping) tile_obj = res$tile_obj      # Seurat object of Tessera tiles"},{"path":"https://korsunskylab.github.io/tessera/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes:","title":"Accurate Tiling of Spatial Single-Cell Data","text":"Quickstart (approx. runtime: <10 sec): vignette(\"vignette_basic\") https://github.com/korsunskylab/tessera/blob/main/vignettes/vignette_basic.ipynb Walkthrough (approx. runtime: <10 sec): vignette(\"vignette_stepthrough\") https://github.com/korsunskylab/tessera/blob/main/vignettes/vignette_stepthrough.ipynb","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/AddAggsAdjacencyMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct tile adjacency matrix from consolidated GetTiles output. — AddAggsAdjacencyMatrix","title":"Construct tile adjacency matrix from consolidated GetTiles output. — AddAggsAdjacencyMatrix","text":"Construct tile adjacency matrix consolidated GetTiles output.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/AddAggsAdjacencyMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct tile adjacency matrix from consolidated GetTiles output. — AddAggsAdjacencyMatrix","text":"","code":"AddAggsAdjacencyMatrix(aggs)"},{"path":"https://korsunskylab.github.io/tessera/reference/AddAggsAdjacencyMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct tile adjacency matrix from consolidated GetTiles output. — AddAggsAdjacencyMatrix","text":"aggs Aggregated tile information consolidation.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/ConsolidateResults.html","id":null,"dir":"Reference","previous_headings":"","what":"Consolidate Tessera results from multiple samples (groups) after constructing Tessera tiles separately on cells from each group. — ConsolidateResults","title":"Consolidate Tessera results from multiple samples (groups) after constructing Tessera tiles separately on cells from each group. — ConsolidateResults","text":"Consolidate Tessera results multiple samples (groups) constructing Tessera tiles separately cells group.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/ConsolidateResults.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consolidate Tessera results from multiple samples (groups) after constructing Tessera tiles separately on cells from each group. — ConsolidateResults","text":"","code":"ConsolidateResults(res, group.by)"},{"path":"https://korsunskylab.github.io/tessera/reference/ConsolidateResults.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consolidate Tessera results from multiple samples (groups) after constructing Tessera tiles separately on cells from each group. — ConsolidateResults","text":"res Output running GetTiles (consolidate == FALSE). group.Name metadata variable identifies distinct groups.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.Seurat.html","id":null,"dir":"Reference","previous_headings":"","what":"Applies Tessera on a Seurat object — GetTiles.Seurat","title":"Applies Tessera on a Seurat object — GetTiles.Seurat","text":"Applies Tessera Seurat object","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.Seurat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applies Tessera on a Seurat object — GetTiles.Seurat","text":"","code":"# S3 method for class 'Seurat' GetTiles(   obj,   spatial,   embeddings = NULL,   assay = NULL,   raw_results = FALSE,   tile.id.name = \"tile_id\",   reduction.name = \"pca\",   graph.name = \"tile_adj\",   ... )"},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.Seurat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Applies Tessera on a Seurat object — GetTiles.Seurat","text":"obj Seurat object spatial coordinates (optionally, pre-computed single cell embeddings) stored dimensional reductions. spatial Name dimensional reduction cells' x/y coordinates stored. embeddings Name dimensional reduction pre-computed single-cell embeddings stored (num_cells x num_dim matrix cell embeddings across latent dimensions). missing, cell embeddings calculated using PCA. provided, npcs parameter ignored. assay Seurat assay pull data using cell counts. Defaults DefaultAssay. raw_results Whether return raw results GetTiles.default(). tile.id.name Name variable store tile IDs cell-level Seurat object. reduction.name Name dimesional reduction store aggregated tile-level embeddings tile-level Seurat object. graph.name Nmae graph store tile adjacency matrix tile-level Seurat object. ... Arguments passed GetTiles.default meta_vars_include Names columns meta_data include dmt$pts. group.Name column meta_data provides group IDs. Tessera tiles constructed separately group (separate experimental samples FOVs). npcs Number PCs compute input segmentation. prune_thresh_quantile Floating point value 0 1, inclusive. Quantile edge length edges pruned. Defaults 0.95. prune_min_cells Minimum number cells required connected component triangles kept. Defaults 10. prune_thresh Edge length edges pruned. equal NA, value ignored thresh_quantile used compute threshold. Otherwise, thresh set, thresh_quantile ignored. Defaults NA. smooth_distance One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_similarity One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_iter Number rounds gradient smoothing. max_npts Maximum number cells allowed tile agglomerative clustering phase. min_npts Minimum number cells allowed tile agglomerative clustering phase. alpha Parameter scoring transcriptional similarity adjacent tiles agglomerative clustering phase. alpha, 0.2 = conservative merging, 2 = liberal merging. consolidate Whether consolidate results multiple groups single collection points tiles (TRUE) return list separate results group (FALSE). verbose Whether print progress messages stage segmentation pipeline.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.Seurat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Applies Tessera on a Seurat object — GetTiles.Seurat","text":"List containing pair Seurat objects: obj: input single-cell object whose meta.data updated tile assignments cell tile_obj: Seurat object item represents individual Tessera tile","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"Segmentation four main steps: Preparing data structures: triangle mesh constructed using Delauney triangulation pruned eliminate long edges. PC embeddings computed. Computing gradients: Gradients calculated point considering difference expression cell neighbors mesh. gradients smoothed using (anisotropic) bilateral filtering, gradients defined edges triangles mesh averaging points edge triangle contains. DMT: scalar field defined taking magnitude total gradient point/edge/triangle. DMT-based segmentation performed constructing maximum spanning forest triangles minimum spanning forest points. Separatrices separate cells tiles homogeneous composition defined tracing paths critical points, particularly saddle edges maximum triangles. Aggregation: Tiles DMT-based segmentation merged using single-linkage agglomerative clustering obtain tiles containing number cells user-provided minimum maximum value. Pairs adjacent tiles scored according transcriptional similarity, compactness shape merging, number cells order prioritize favorable merges agglomerative clustering step.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"","code":"# Default S3 method GetTiles(   X,   Y,   counts = NULL,   embeddings = NULL,   loadings = NULL,   meta_data = NULL,   meta_vars_include = NULL,   group.by = NULL,   npcs = 10,   prune_thresh_quantile = 0.95,   prune_min_cells = 10,   prune_thresh = NA,   smooth_distance = c(\"none\", \"euclidean\", \"projected\", \"constant\")[3],   smooth_similarity = c(\"none\", \"euclidean\", \"projected\", \"constant\")[3],   smooth_iter = 1,   max_npts = 50,   min_npts = 5,   alpha = 1,   .progress = TRUE,   .options = NULL,   consolidate = TRUE,   verbose = FALSE )"},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"X, Y pair numeric vectors coordinates num_cells points. counts num_genes x num_cells gene--cell matrix transcript counts. Optional embeddings provided directly. embeddings num_cells x num_dim matrix cell embeddings across latent dimensions. missing, cell embeddings calculated using PCA. provided, npcs parameter ignored. loadings (Optional) num_genes x num_dim matrix gene loadings. meta_data data frame additional cell metadata include dmt$pts. meta_vars_include Names columns meta_data include dmt$pts. group.Name column meta_data provides group IDs. Tessera tiles constructed separately group (separate experimental samples FOVs). npcs Number PCs compute input segmentation. prune_thresh_quantile Floating point value 0 1, inclusive. Quantile edge length edges pruned. Defaults 0.95. prune_min_cells Minimum number cells required connected component triangles kept. Defaults 10. prune_thresh Edge length edges pruned. equal NA, value ignored thresh_quantile used compute threshold. Otherwise, thresh set, thresh_quantile ignored. Defaults NA. smooth_distance One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_similarity One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_iter Number rounds gradient smoothing. max_npts Maximum number cells allowed tile agglomerative clustering phase. min_npts Minimum number cells allowed tile agglomerative clustering phase. alpha Parameter scoring transcriptional similarity adjacent tiles agglomerative clustering phase. alpha, 0.2 = conservative merging, 2 = liberal merging. consolidate Whether consolidate results multiple groups single collection points tiles (TRUE) return list separate results group (FALSE). verbose Whether print progress messages stage segmentation pipeline.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"consolidate==TRUE, List results segmentation, combined across groups (otherwise, consolidate==FALSE, named List, contains separate results group): dmt Mesh data structures input points/edges/triangles results segmentation: pts: data table num_cells_pruned rows containing cells mesh remain Delauney triangulation pruning, following columns: X,Y: Coordinates cell. ORIG_ID: Index cell original inputs GetTiles() (X, Y, counts, meta_data) Columns meta_vars_include. f: Scalar value used initial DMT-based segmentation, computed spatial gradient expression point. agg_id: Unique ID tile point belongs final segmentation. tris: data table num_triangles rows containing triangles mesh Delauney triangulation pruning, following columns: X,Y: Coordinates triangle's centroid. area: Area triangle. height: Largest height triangle. external: Logical value TRUE triangle degenerate triangle added along boundary edge ensure every edge adjacent two triangles. Degenerate triangles two vertices (endpoints boundary edge). f: Scalar value used initial DMT-based segmentation, computed spatial gradient expression triangle. edges: data table num_edges rows containing edges adjacent points triangles mesh Delauney triangulation pruning, following columns: from_pt,to_pt: Indices two adjacent cells connected edge. from_tri,to_tri: Indices two adjacent triangles connected edge. x0_pt,x1_pt,y0_pt,y1_pt: Coordinates two adjacent cells connected edge. x0_tri, x1_tri, y0_tri, y1_tri: Coordinates two adjacent triangles (centroids) connected edge. length_pt, length_tri: Distance adjacent cells triangle centroids. Used pruning step. (Warning - computed prior pruning updated pruning adding exterior triangles.) boundary: Logical value TRUE edge boundary adjacent single internal triangle. boundary edges, degenerate external triangle added along boundary edge ensure every edge adjacent two triangles. f_prim,f_dual: Scalar values used initial DMT-based segmentation, computed spatial gradient expression edge. Primal edges connect points average f values two adjacent points. Dual edges connect triangles average f values two adjacent triangles. agg_from,agg_to: Unique ID tile adjacent point belongs final segmentation. tri_to_pt: num_triangles x num_cells_pruned sparse matrix value 1 (,j) triangle point j vertex. internal triangle 3 vertices, degenerate external triangle 2 vertices. counts: num_genes x num_cells_pruned gene--cell matrix transcript counts. udv_cells: List PC embeddings cell, used segmentation. loadings: provided input, num_genes x npcs matrix gene loadings PC. column unit vector. embeddings: provided input, num_cells x npcs matrix cell embeddings across PCs. column j magnitude equal jth singular value. , PCs larger contribution total variance embeddings proportionally larger magnitude. prim: primal minimum spanning forest points. List following attributes: edges: data table forest_size rows, row directed edge minimum spanning forest. six columns: ,: Index source target points edge. x0,y0: Coordinates source point edge. x1,y1: Coordinates target point edge. saddles: length num_saddles vector edge indices possible saddle edges. labels: length num_points vector labels connected components minimum spanning tree. connected component labeled index critical point. minima: length num_critpts vector critical points (minima). parent: length num_points vector containing parent (source) point point directed spanning forest. Critical points parent, value ignored. parent_edge: length num_points vector containing directed edge point target node. Critical points parent edge, value ignored. dual: dual maximum spanning forest triangles. List following attributes: edges: data.table forest_size rows, row directed edge maximum spanning forest. six columns: ,: Index source target triangles edge. x0,y0: Coordinates source triangle edge. x1,y1: Coordinates target triangle edge. saddles: length num_saddles vector edge indices possible saddle edges. labels: length num_triangles vector labels connected components maximum spanning tree. connected component labeled index critical triangle. maxima: length num_critpts vector critical triangles (maxima). parent: length num_triangles vector containing parent (source) triangle triangle directed spanning forest. Critical triangles parent, value ignored. parent_edge: length num_triangles vector containing directed edge triangle target node. Critical triangles parent edge, value ignored. e_sep: length num_sep_edges vector edge indices make separatrices, separate points different components. aggs tiles result DMT-based segmentation agglomeration. List data structure stores tiles adjacencies using following attributes: meta_data: data table num_tiles rows metadata tile: ID: Unique ID tile. X,Y: Centroid tile. npts: Number points tile. shape: sfc list-column geometries tile. area,perimeter: Area perimeter tile. edges: Additional attributes calculated: ,: Tile IDs two tiles bordering edge. x0,y0,x1,y1: Centroid coordinates two tiles bordering edge. area,npts: Sum areas numbers points two tiles bordering edge. edge_length: Total length border tiles. dscore: Overall score merging two tiles. Product w, score_size, dC. w: Gene expression similarity score. score_size: Penalizes tiles many points. perimeter_merge: Perimeter merged tile. pcs: num_tiles x npcs matrix average embedding value cells tile. pcs_merged: num_edges x npcs matrix average PCs new tile two adjacent tiles connected edge merged. d_mu,d_sig: Parameters used calculate w edge score dscore. aggmap: length orig_num_tiles vector mapping original tile ID new tile IDs merging. adj: Sparse adjacency matrix tiles (consolidate==TRUE). counts: num_genes x num_tiles gene--tile matrix aggregated transcript counts.","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":"computing-gradients-smoothing-","dir":"Reference","previous_headings":"","what":"Computing gradients (smoothing)","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"Gradient fields smoothed using bilateral filtering, smoothed gradient point computed weighted average neighbors' gradients, considering distance space also similarity gradients. weight neighbor computed product two scores: distance score: Generally, closer neighbors greater weight. 'euclidean': Gaussian transformation Euclidean distance cell neighbor, distant neighbors less weight. 'projected': anisotropic filter accounts expected change expression along direction neighbor. expected change expression calculated gradient field total derivative direction neighbor. change expression Gaussian transformed neighbors distant along direction greatest change less weight. 'constant': neighbors equal distance weights similarity score: Generally, neighbors similar gradients greater weight 'euclidean': Gaussian transformation Euclidean distance cell's gradient field neighbor's gradient field. 'projected': Gaussian transformation cosine distance cell's gradient field neighbor's gradient field. 'constant': neighbors equal similarity weights","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.default.html","id":"aggregation-scores-","dir":"Reference","previous_headings":"","what":"Aggregation (scores)","title":"Run full DMT segmentation pipeline to make aggregated tiles from cells — GetTiles.default","text":"Pairs adjacent tiles scored according transcriptional similarity, compactness shape merging, number cells order prioritize favorable merges agglomerative clustering step. dscore edge computed product following three factors, higher scores favor merging adjacent tiles: w: 2-cluster GMM used determine mean mu standard deviation sig distance tiles similar gene expression (Euclidean distance d PC space). define d_mu = mu + sig d_sig = alpha * sig, calculate w w = 0.5 - 1 / (1 + exp(-(d - d_mu) / d_sig)). Ranges -0.5 0.5. adjacent tiles dissimilar (d >> d_mu), d large, w close -0.5. adjacent tiles similar (d < d_mu), d small, w positive. score_size: (1 - npts_from/max_npts) * (1 - npts_to/max_npts). Ranges 0 1. first round aggregation, merging two tiles total number points ≥max_npts, score_size set -Inf, prevents merging. second round aggregation, dscore set -Inf adjacent tiles least min_npts cells, prioritize merging small tiles. dC: .5 * (C_merge - C_from - C_to + 1). Ranges 0 1.","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic function that runs the Tessera algorithm on single-cell spatial data — GetTiles","title":"Generic function that runs the Tessera algorithm on single-cell spatial data — GetTiles","text":"GetTiles generic function runs main Tessera algorithm. working Seurat object, please refer documentation appropriate generic API: GetTiles.Seurat(). users work forms input, can pass directly Tessera using GetTiles.default() API. function arguments listed common GetTiles interfaces.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic function that runs the Tessera algorithm on single-cell spatial data — GetTiles","text":"","code":"GetTiles(...)"},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic function that runs the Tessera algorithm on single-cell spatial data — GetTiles","text":"... Arguments passed GetTiles.default meta_vars_include Names columns meta_data include dmt$pts. group.Name column meta_data provides group IDs. Tessera tiles constructed separately group (separate experimental samples FOVs). npcs Number PCs compute input segmentation. prune_thresh_quantile Floating point value 0 1, inclusive. Quantile edge length edges pruned. Defaults 0.95. prune_min_cells Minimum number cells required connected component triangles kept. Defaults 10. prune_thresh Edge length edges pruned. equal NA, value ignored thresh_quantile used compute threshold. Otherwise, thresh set, thresh_quantile ignored. Defaults NA. smooth_distance One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_similarity One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none', smoothing gradient field conducted. Defaults 'projected'. smooth_iter Number rounds gradient smoothing. max_npts Maximum number cells allowed tile agglomerative clustering phase. min_npts Minimum number cells allowed tile agglomerative clustering phase. alpha Parameter scoring transcriptional similarity adjacent tiles agglomerative clustering phase. alpha, 0.2 = conservative merging, 2 = liberal merging. consolidate Whether consolidate results multiple groups single collection points tiles (TRUE) return list separate results group (FALSE). verbose Whether print progress messages stage segmentation pipeline.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/GetTiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic function that runs the Tessera algorithm on single-cell spatial data — GetTiles","text":"used Seurat object, return pair Seurat objects: input single-cell object updated tile assignments cell, Seurat object item represents individual Tessera tile. standalone operation, returns Lists output Tessera segmentation (see GetTiles.default()).","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/reference/add_exterior_triangles.html","id":null,"dir":"Reference","previous_headings":"","what":"For every edge on the boundary, adds a second degenerate triangle — add_exterior_triangles","title":"For every edge on the boundary, adds a second degenerate triangle — add_exterior_triangles","text":"Edges boundary border single triangle. order deal boundary conditions properly, step ensures every edge two associated triangles (use edge) well two associated points (endpoints). triangles added degenerate triangles centered midpoint boundary edge.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/add_exterior_triangles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"For every edge on the boundary, adds a second degenerate triangle — add_exterior_triangles","text":"","code":"add_exterior_triangles(data)"},{"path":"https://korsunskylab.github.io/tessera/reference/add_exterior_triangles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"For every edge on the boundary, adds a second degenerate triangle — add_exterior_triangles","text":"data list containing mesh data structures: pts V--M data table columns X Y containing coordinates cells additional metadata. tris F--4 data table containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns. edges E--14 data table columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. tri_to_pt F--V sparse matrix value 1 (,j) triangle uses point j vertex.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/add_exterior_triangles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"For every edge on the boundary, adds a second degenerate triangle — add_exterior_triangles","text":"list containing mesh data structures (possibly) additional triangles. tris table updated include added external triangles. edge table updated boundary edges point newly added triangles. Also pts unchanged, tri_to_pt updated. new external triangles 2 associated points, tri_to_pt rows sum either 2 3.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/assign_unique_rowid_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns a unique ID to each point with distinct X,Y coordinates — assign_unique_rowid_cpp","title":"Assigns a unique ID to each point with distinct X,Y coordinates — assign_unique_rowid_cpp","text":"Assigns unique ID point distinct X,Y coordinates","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/assign_unique_rowid_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns a unique ID to each point with distinct X,Y coordinates — assign_unique_rowid_cpp","text":"","code":"assign_unique_rowid_cpp(X, Y)"},{"path":"https://korsunskylab.github.io/tessera/reference/assign_unique_rowid_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns a unique ID to each point with distinct X,Y coordinates — assign_unique_rowid_cpp","text":"X, Y pair numeric vectors coordinates point.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/assign_unique_rowid_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assigns a unique ID to each point with distinct X,Y coordinates — assign_unique_rowid_cpp","text":"vector length X Y containing IDs range 0 N N number unique points.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_field_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compress a gradient field using SVD — compress_field_cpp","title":"Compress a gradient field using SVD — compress_field_cpp","text":"Expresses 2 x D total derivative location pair 2-dimensional vectors gradient orthogonal directions.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_field_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compress a gradient field using SVD — compress_field_cpp","text":"","code":"compress_field_cpp(field)"},{"path":"https://korsunskylab.github.io/tessera/reference/compress_field_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compress a gradient field using SVD — compress_field_cpp","text":"field 2 x D x N array column-major ordering containing spatial gradient expression D latent variables every point, edge, triangle.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_field_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compress a gradient field using SVD — compress_field_cpp","text":"N x 6 matrix following attributes location: dx grad,dy grad x,y directions unit vector direction greatest change (first singular vector). dx ortho,dy ortho x,y directions unit vector orthogonal direction greatest change (second singular vector). |grad|,|ortho| Magnitude directional derivative gradient orthogonal directions (singular values).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_gradients_svd.html","id":null,"dir":"Reference","previous_headings":"","what":"Compress a gradient field using SVD — compress_gradients_svd","title":"Compress a gradient field using SVD — compress_gradients_svd","text":"Expresses 2 x D total derivative location pair 2-dimensional vectors gradient orthogonal directions.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_gradients_svd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compress a gradient field using SVD — compress_gradients_svd","text":"","code":"compress_gradients_svd(field)"},{"path":"https://korsunskylab.github.io/tessera/reference/compress_gradients_svd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compress a gradient field using SVD — compress_gradients_svd","text":"field gradient field following attributes: pts: 2 x D x N array column-major ordering containing spatial gradient expression D latent variables every point space. tris: 2 x D x F array column-major ordering containing spatial gradient expression D latent variables every triangle mesh. Average vertices (3 full triangles, 2 degenerate triangles). edges_pts: 2 x D x E array column-major ordering containing spatial gradient expression D latent variables every primal edge (point--point) mesh. Sum two endpoints. edges_tris: 2 x D x E array column-major ordering containing spatial gradient expression D latent variables every dual edge (triangle--triangle) mesh. Sum two adjacent triangles.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compress_gradients_svd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compress a gradient field using SVD — compress_gradients_svd","text":"gradient field attributes input, well compressed representations pts_svd, tris_svd, edges_pts_svd, edges_tris_svd. N x 6 matrix following columns location: dx_grad,dy_grad x,y directions unit vector direction greatest change (first singular vector). dx_ortho,dy_ortho x,y directions unit vector orthogonal direction greatest change (second singular vector). len_grad,len_ortho Magnitude directional derivative gradient orthogonal directions (singular values).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compute_gradients.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute spatial gradient field for input to DMT — compute_gradients","title":"Compute spatial gradient field for input to DMT — compute_gradients","text":"First, spatial gradients embedding dimension computed every points (cell) looking cell's neighbors. point gradients can smoothed using bilateral/anisotropic filtering. gradients triangles computed average vertices (3 proper triangles, 2 degenerate exterior triangles boundaries). Finally, primal dual edge gradients computed sum gradients two points two triangles, respectively, associated edge.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compute_gradients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute spatial gradient field for input to DMT — compute_gradients","text":"","code":"compute_gradients(   dmt,   smooth_distance = \"none\",   smooth_similarity = \"none\",   smooth_iter = 1 )"},{"path":"https://korsunskylab.github.io/tessera/reference/compute_gradients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute spatial gradient field for input to DMT — compute_gradients","text":"dmt list containing mesh data structures: pts N x 2+M data table columns X Y containing coordinates cells additional metadata. tris F x 4 data table containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns. edges E x 14 data table columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. tri_to_pt F x N sparse matrix value 1 (,j) triangle uses point j vertex. udv_cells contains cell embeddings stored embeddings (N x D matrix D-dimensional embeddings cell) loadings (G x D matrix gene loadings latent variable). smooth_distance One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none' (default), smoothing gradient field conducted. smooth_similarity One c('none', 'euclidean', 'projected', 'constant'). either smooth_distance smooth_similarity 'none' (default), smoothing gradient field conducted. smooth_iter Number rounds gradient smoothing.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/compute_gradients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute spatial gradient field for input to DMT — compute_gradients","text":"gradient field following attributes: pts 2 x D x N array column-major ordering containing spatial gradient expression D latent variables every point space. tris 2 x D x F array column-major ordering containing spatial gradient expression D latent variables every triangle mesh. Average vertices (3 full triangles, 2 degenerate triangles). edges_pts 2 x D x E array column-major ordering containing spatial gradient expression D latent variables every primal edge (point--point) mesh. Average two endpoints. edges_tris 2 x D x E array column-major ordering containing spatial gradient expression D latent variables every dual edge (triangle--triangle) mesh. Average two adjacent triangles.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_assign_tiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign points to tiles after DMT — dmt_assign_tiles","title":"Assign points to tiles after DMT — dmt_assign_tiles","text":"Tiles defined points connected component mesh discounting separatrix edges.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_assign_tiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign points to tiles after DMT — dmt_assign_tiles","text":"","code":"dmt_assign_tiles(dmt)"},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_assign_tiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign points to tiles after DMT — dmt_assign_tiles","text":"dmt DMT data structure edges, pts, e_sep attributes.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_assign_tiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign points to tiles after DMT — dmt_assign_tiles","text":"DMT data structure following additional attributes: pts$agg_id: Unique ID tile point belongs . edges$agg_from: Unique ID tile edges$from_pt belongs . edges$agg_to: Unique ID tile edges$to_pt belongs .","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","title":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","text":"Finds collection edges lie along separatrices. found tracing paths saddles critical triangles (maxima) dual spanning forest. dual spanning forest maximum spanning forest triangles mesh, paths follow ridges, separating points components strongest boundaries.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","text":"","code":"dmt_get_separatrices(dmt)"},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","text":"dmt DMT data structure following attributes: edges: Data structure edges mesh. prim: Data structure primal minimum spanning forest. dual: Data structure dual maximum spanning forest.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","text":"length num_sep_edges vector edges (1-indexed) make separatrices separate points different components.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_get_separatrices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get separatrices that separate points into components with strong boundaries — dmt_get_separatrices","text":"Saddle edges found interesting saddle edges found primal forest saddles edges found dual forest. boundary edges dual forest also included possible saddle edges.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_init_tiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize tiles with shapes and other properties — dmt_init_tiles","title":"Initialize tiles with shapes and other properties — dmt_init_tiles","text":"Initialize tiles shapes properties","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_init_tiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize tiles with shapes and other properties — dmt_init_tiles","text":"","code":"dmt_init_tiles(dmt)"},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_init_tiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize tiles with shapes and other properties — dmt_init_tiles","text":"dmt DMT data structure pts, edges, udv_cells attributes. Assignment points tiles provided dmt$pts$agg_id, dmt$edges$agg_from, dmt$edges$agg_to.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_init_tiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize tiles with shapes and other properties — dmt_init_tiles","text":"list data structure tiles adjacencies. Includes following attributes: meta_data: data table attributes tiles: X,Y: Centroid tile. npts: Number points tile. shape: sfc list-column geometries tile. area,perimeter: Area perimeter tile. edges: data table attributes edges adjacent tiles: ,: Tile IDs two tiles bordering edge. x0,y0,x1,y1: Centroid coordinates two tiles bordering edge. area,npts: Sum areas numbers points two tiles bordering edge. edge_length: Total length border tiles. pcs: num_tiles x npcs matrix average embedding value cells tile.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_set_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Set DMT scalar field values as the Frobenius norm of the total derivative — dmt_set_f","title":"Set DMT scalar field values as the Frobenius norm of the total derivative — dmt_set_f","text":"Set DMT scalar field values Frobenius norm total derivative","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_set_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set DMT scalar field values as the Frobenius norm of the total derivative — dmt_set_f","text":"","code":"dmt_set_f(dmt, field)"},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_set_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set DMT scalar field values as the Frobenius norm of the total derivative — dmt_set_f","text":"dmt list containing mesh data structures: pts N x 2+M data table columns X Y containing coordinates cells additional metadata. tris F x 4 data table containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns. edges E x 14 data table columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. tri_to_pt F x N sparse matrix value 1 (,j) triangle uses point j vertex. udv_cells contains cell embeddings stored embeddings (N x D matrix D-dimensional embeddings cell) loadings (G x D matrix gene loadings latent variable). field gradient field compressed representations pts_svd, tris_svd, edges_pts_svd, edges_tris_svd. N x 6 matrix following columns location: dx_grad,dy_grad: x,y directions unit vector direction greatest change (first singular vector). dx_ortho,dy_ortho: x,y directions unit vector orthogonal direction greatest change (second singular vector). len_grad,len_ortho: Magnitude directional derivative gradient orthogonal directions (singular values).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/dmt_set_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set DMT scalar field values as the Frobenius norm of the total derivative — dmt_set_f","text":"dmt following additional attributes: dmt$pts$f, dmt$tris$f, dmt$edges$f_prim, dmt$edges$f_dual","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dmt_forest_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct maximum spanning forest — do_dmt_forest_cpp","title":"Construct maximum spanning forest — do_dmt_forest_cpp","text":"Constructs directed maximum spanning forest point edge scalar values using version Prim's algorithm. Critical points (local maxima; , precisely, endpoint edge local maxima) used roots tree forest, edges bridge two trees different critical point roots marked possible saddle edges.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dmt_forest_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct maximum spanning forest — do_dmt_forest_cpp","text":"","code":"do_dmt_forest_cpp(f, edges_from, edges_to, edges_f)"},{"path":"https://korsunskylab.github.io/tessera/reference/do_dmt_forest_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct maximum spanning forest — do_dmt_forest_cpp","text":"f Vector num_points scalar values defined point. edges_from Vector num_edges indices first end-point edge (0-indexed). edges_to Vector num_edges indices second end-point edge (0-indexed). edges_f Vector num_edges scalar values defined along edge.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dmt_forest_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct maximum spanning forest — do_dmt_forest_cpp","text":"List following attributes (indices 1-indexed): edges: forest_size x 2 matrix row directed edge maximum spanning forest. first column source point edge second column target point. saddles: length num_saddles vector edge indices possible saddle edges. labels: length num_points vector labels connected components maximum spanning tree. connected component labeled index critical point. critpts: length num_critpts vector critical points (maxima). parent: length num_points vector containing parent (source) point point directed spanning forest. Critical points parent, value ignored. parent_edge: length num_points vector containing directed edge point target node. Critical points parent edge, value ignored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dual_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct dual maximum spanning forest on triangles — do_dual_forest","title":"Construct dual maximum spanning forest on triangles — do_dual_forest","text":"Constructs directed maximum spanning forest triangle edge scalar values using version Prim's algorithm. Critical triangles (local maximum; , precisely, triangle contains edge local maximum) used roots tree forest, edges bridge two trees different critical triangle roots marked possible saddle edges.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dual_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct dual maximum spanning forest on triangles — do_dual_forest","text":"","code":"do_dual_forest(dmt)"},{"path":"https://korsunskylab.github.io/tessera/reference/do_dual_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct dual maximum spanning forest on triangles — do_dual_forest","text":"dmt DMT data structure following attributes: tris$f: Scalar field values defined triangle. edges$from_tri: Index first triangle joined edge. edges$to_tri: Index second triangle joined edge. edges$f_dual: Scalar field values defined edge connects two triangles.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_dual_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct dual maximum spanning forest on triangles — do_dual_forest","text":"List following attributes (indices 1-indexed): edges: data.table forest_size rows, row directed edge maximum spanning forest. six columns: ,: Index source target triangles edge. x0,y0: Coordinates source triangle edge. x1,y1: Coordinates target triangle edge. saddles: length num_saddles vector edge indices possible saddle edges. labels: length num_triangles vector labels connected components maximum spanning tree. connected component labeled index critical triangle. maxima: length num_critpts vector critical triangles (maxima). parent: length num_triangles vector containing parent (source) triangle triangle directed spanning forest. Critical triangles parent, value ignored. parent_edge: length num_triangles vector containing directed edge triangle target node. Critical triangles parent edge, value ignored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute PCA embeddings from a raw counts matrix — do_pca","title":"Compute PCA embeddings from a raw counts matrix — do_pca","text":"First, log-normalizes Z-scores counts matrix performs PCA using SVD.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute PCA embeddings from a raw counts matrix — do_pca","text":"","code":"do_pca(counts, npcs)"},{"path":"https://korsunskylab.github.io/tessera/reference/do_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute PCA embeddings from a raw counts matrix — do_pca","text":"counts n_genes x n_cells counts matrix. Must convertible dgCMatrix. npcs Number PCs compute.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute PCA embeddings from a raw counts matrix — do_pca","text":"list two features: loadings: n_genes x npcs matrix gene loadings PC. column unit vector. embeddings: n_cells x npcs matrix cell embeddings across PCs. column j magnitude equal jth singular value. , PCs larger contribution total variance embeddings proportionally larger magnitude.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_primary_forest.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct primal minimum spanning forest on points — do_primary_forest","title":"Construct primal minimum spanning forest on points — do_primary_forest","text":"Constructs directed minimum spanning forest point edge scalar values using version Prim's algorithm. Critical points (local minimum; , precisely, endpoint edge local minimum) used roots tree forest, edges bridge two trees different critical point roots marked possible saddle edges.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_primary_forest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct primal minimum spanning forest on points — do_primary_forest","text":"","code":"do_primary_forest(dmt)"},{"path":"https://korsunskylab.github.io/tessera/reference/do_primary_forest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct primal minimum spanning forest on points — do_primary_forest","text":"dmt DMT data structure following attributes: pts$f: Scalar field values defined point. edges$from_pt: Index first point joined edge. edges$to_pt: Index second point joined edge. edges$f_prim: Scalar field values defined edge connects two points.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/do_primary_forest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct primal minimum spanning forest on points — do_primary_forest","text":"List following attributes (indices 1-indexed): edges: data.table forest_size rows, row directed edge minimum spanning forest. six columns: ,: Index source target points edge. x0,y0: Coordinates source point edge. x1,y1: Coordinates target point edge. saddles: length num_saddles vector edge indices possible saddle edges. labels: length num_points vector labels connected components minimum spanning tree. connected component labeled index critical point. minima: length num_critpts vector critical points (minima). parent: length num_points vector containing parent (source) point point directed spanning forest. Critical points parent, value ignored. parent_edge: length num_points vector containing directed edge point target node. Critical points parent edge, value ignored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a spatial gradient field at each point (cell) — estimate_field","title":"Compute a spatial gradient field at each point (cell) — estimate_field","text":"Distance neighboring cells normalized unit distance direction cell neighbors matters. gradient average gradient expression embedding dimension index cell neighbors.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a spatial gradient field at each point (cell) — estimate_field","text":"","code":"estimate_field(coords, adj, embeddings)"},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a spatial gradient field at each point (cell) — estimate_field","text":"coords N x 2 matrix cell coordinates. adj N x N sparse adjacency matrix dgCMatrix format. embeddings N x D matrix cell embeddings.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a spatial gradient field at each point (cell) — estimate_field","text":"2 x D x N array column-major ordering containing spatial gradient expression D embedding dimensions every point space.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a spatial gradient field at each point (cell) — estimate_field_cpp","title":"Compute a spatial gradient field at each point (cell) — estimate_field_cpp","text":"Distance neighboring cells normalized unit distance direction cell neighbors matters. gradient average gradient expression embedding dimension index cell neighbors.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a spatial gradient field at each point (cell) — estimate_field_cpp","text":"","code":"estimate_field_cpp(coords, embeddings, adj_i, adj_p)"},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a spatial gradient field at each point (cell) — estimate_field_cpp","text":"coords N x 2 matrix cell coordinates. embeddings N x D matrix cell embeddings. adj_i, adj_p N x N sparse adjacency matrix dgCMatrix format.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/estimate_field_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a spatial gradient field at each point (cell) — estimate_field_cpp","text":"2 x D x N array column-major ordering containing spatial gradient expression D embedding dimensions every point space.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/findDuplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Find duplicates within a vector — findDuplicates","title":"Find duplicates within a vector — findDuplicates","text":"Find duplicates within vector","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/findDuplicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find duplicates within a vector — findDuplicates","text":"","code":"findDuplicates(input)"},{"path":"https://korsunskylab.github.io/tessera/reference/findDuplicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find duplicates within a vector — findDuplicates","text":"input Vector values.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/findDuplicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find duplicates within a vector — findDuplicates","text":"Vector values input appear least twice. value appears N times input appear N-1 times output.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/get_e_sep.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the collection of edges that lie along separatrices — get_e_sep","title":"Get the collection of edges that lie along separatrices — get_e_sep","text":"Get collection edges lie along separatrices","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/get_e_sep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the collection of edges that lie along separatrices — get_e_sep","text":"","code":"get_e_sep(epaths, saddles, nedges)"},{"path":"https://korsunskylab.github.io/tessera/reference/get_e_sep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the collection of edges that lie along separatrices — get_e_sep","text":"epaths list length 2*num_saddles containing two paths saddle edge two critical points joins. path numeric vector edge indices (1-indexed). saddles length num_saddles vector edge indices saddle edges (1-indexed). nedges Total number edges mesh.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/get_e_sep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the collection of edges that lie along separatrices — get_e_sep","text":"length num_sep_edges vector edges (0-indexed) saddle edges saddles lie along paths epaths. edges make separatrices separate points different components.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate mesh data structure from coordinates, for input to DMT analysis — init_data","title":"Generate mesh data structure from coordinates, for input to DMT analysis — init_data","text":"Creates mesh point coordinates using Delauney triangulation. Stores points, triangles, edges mesh, well mapping triangle associated vertices. gene--cell matrix can also included, well additional metadata point.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate mesh data structure from coordinates, for input to DMT analysis — init_data","text":"","code":"init_data(X, Y, counts, meta_data = NULL, meta_vars_include = c())"},{"path":"https://korsunskylab.github.io/tessera/reference/init_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate mesh data structure from coordinates, for input to DMT analysis — init_data","text":"X, Y pair numeric vectors coordinates V points. counts G x V gene--cell matrix transcript counts. meta_data data frame additional cell metadata include. meta_vars_include Names columns meta_data include.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate mesh data structure from coordinates, for input to DMT analysis — init_data","text":"list containing mesh data structures: pts V--M data table columns X Y containing coordinates cells additional metadata. tris F--4 data table containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns. edges E--14 data table columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. tri_to_pt F--V sparse matrix value 1 (,j) triangle uses point j vertex. counts G x V gene--cell matrix transcript counts. Note indices stored data structures 1-indexed.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_edges_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates triangles' centroids, areas, and heights from vertices — init_edges_cpp","title":"Calculates triangles' centroids, areas, and heights from vertices — init_edges_cpp","text":"Calculates triangles' centroids, areas, heights vertices","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_edges_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates triangles' centroids, areas, and heights from vertices — init_edges_cpp","text":"","code":"init_edges_cpp(triplets, pts, tris)"},{"path":"https://korsunskylab.github.io/tessera/reference/init_edges_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates triangles' centroids, areas, and heights from vertices — init_edges_cpp","text":"triplets M--3 matrix indices points correspond triangle's vertices, M number triangles. pts N--2 matrix indices X,Y coordinates point. tris M--4 matrix containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_edges_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates triangles' centroids, areas, and heights from vertices — init_edges_cpp","text":"E--14 matrix columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. Note indices reference pts tris tables 1-indexed.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize tile scores for aggregation — init_scores","title":"Initialize tile scores for aggregation — init_scores","text":"Higher scores favor merging.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize tile scores for aggregation — init_scores","text":"","code":"init_scores(aggs, agg_mode, ...)"},{"path":"https://korsunskylab.github.io/tessera/reference/init_scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize tile scores for aggregation — init_scores","text":"aggs tile data structure. agg_mode Method use calculate aggregation scores (1, 2, 3). ... Additional parameters different modes: additional parameters. Requires alpha max_npts. alpha, 0.2 = conservative merging, 2 = liberal merging. Requires alpha min_npts. alpha, 0.2 = conservative merging, 2 = liberal merging.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize tile scores for aggregation — init_scores","text":"aggs scores aggregation stored attributes: edges Additional attributes calculated: * dscore: Overall score merging two tiles. Product w, score_size, dC. * w: Gene expression similarity score. * score_size: Penalizes tiles many points. * perimeter_merge: Perimeter merged tile. d_mu,d_sig Parameters used calculate w. pcs_merged Average PCs merged tile.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initialize tile scores for aggregation — init_scores","text":"Methods different modes aggregation: dscore already manually calculated stored aggs$edges$dscore. set score, score_size, compactness attributes aggs$meta_data 0. dscore product three factors: w: 2-cluster GMM used determine mean mu standard deviation sig distance tiles similar gene expression (Euclidean distance d PC space). define d_mu = mu + sig d_sig = alpha * sig, calculate w w = 0.5 - 1 / (1 + exp(-(d - d_mu) / d_sig)). Ranges -0.5 0.5. adjacent tiles dissimilar (d >> d_mu), d large, w close -0.5. adjacent tiles similar (d < d_mu), d small, w positive. score_size: (1 - npts_from/max_npts) * (1 - npts_to/max_npts). Ranges 0 1. merging two tiles total number points ≥max_npts, score_size -Inf, prevents merging. dC: .5 * (C_merge - C_from - C_to + 1). Ranges 0 1. dscore product three factors mode 2, score_size already precomputed. Additionally, dscore set -1 adjacent tiles least min_npts cells.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_tris_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates triangles' centroids, areas, and heights from vertices — init_tris_cpp","title":"Calculates triangles' centroids, areas, and heights from vertices — init_tris_cpp","text":"Calculates triangles' centroids, areas, heights vertices","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_tris_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates triangles' centroids, areas, and heights from vertices — init_tris_cpp","text":"","code":"init_tris_cpp(triplets, pts)"},{"path":"https://korsunskylab.github.io/tessera/reference/init_tris_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates triangles' centroids, areas, and heights from vertices — init_tris_cpp","text":"triplets M--3 matrix indices points correspond triangle's vertices, M number triangles. pts N--2 matrix indices X,Y coordinates point.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/init_tris_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates triangles' centroids, areas, and heights from vertices — init_tris_cpp","text":"M--4 matrix containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/mergeListsToArmaUVec.html","id":null,"dir":"Reference","previous_headings":"","what":"Copies elements from two lists an Armadillo uvec — mergeListsToArmaUVec","title":"Copies elements from two lists an Armadillo uvec — mergeListsToArmaUVec","text":"Concatenates values list1 list2.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/mergeListsToArmaUVec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copies elements from two lists an Armadillo uvec — mergeListsToArmaUVec","text":"","code":"mergeListsToArmaUVec(list1, list2)"},{"path":"https://korsunskylab.github.io/tessera/reference/mergeListsToArmaUVec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copies elements from two lists an Armadillo uvec — mergeListsToArmaUVec","text":"list1, list2 Lists unsigned values.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/mergeListsToArmaUVec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copies elements from two lists an Armadillo uvec — mergeListsToArmaUVec","text":"Armadillo uvec concatenates list1 list2.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs.html","id":null,"dir":"Reference","previous_headings":"","what":"Merges tiles using single-linkage agglomerative clustering — merge_aggs","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs","text":"Note function mutates many input values keep track updated values tiles borders successive merge. Every merge adjacent tiles associated score (higher means merging favorable). Merging conducted greedily, one step time, updating score associated pair tiles step.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs","text":"","code":"merge_aggs(   aggs,   agg_mode,   d_mu = NULL,   d_sig = NULL,   iter_max = NULL,   dscore_thresh = 0,   min_npts = 0,   max_npts = Inf,   min_area = 0,   max_area = Inf )"},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs","text":"aggs data structure updated values meta_data data table attributes new merged tiles: * X,Y: Centroid tile. (updated) * npts: Number points tile. (Updated) * shape: sfc list-column geometries tile. (updated) * area,perimeter: Area perimeter tile. (Updated) edges data table attributes edges adjacent merged tiles, edges infinite dscore removed: * ,: Tile IDs two tiles bordering edge. (Updated new merged tiles) * x0,y0,x1,y1: Centroid coordinates two tiles bordering edge. (updated) * area,npts: Sum areas numbers points two tiles bordering edge. (Updated) * edge_length: Total length border tiles. (Updated) * dscore: Overall score merging two tiles. Product w, score_size, dC. (Updated) * w: Gene expression similarity score. (Updated) * score_size: Penalizes tiles many points. (Updated) * perimeter_merge: Perimeter merged tile. (Updated) pcs num_tiles x npcs matrix average embedding value cells tile. (Updated) pcs_merged num_edges x npcs matrix average PCs merged tiles. (Updated) d_mu,d_sig Parameters used calculate w. aggmap length orig_num_tiles vector mapping original tile ID new tile IDs merging.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Merges tiles using single-linkage agglomerative clustering — merge_aggs_cpp","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs_cpp","text":"Note function mutates many inputs keep track updated values tiles borders successive merge. Every merge adjacent tiles associated score (higher means merging favorable). Merging conducted greedily, one step time, updating score associated pair tiles step.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs_cpp","text":"","code":"merge_aggs_cpp(   V_pcs,   V_area,   V_perimeter,   V_npts,   E_from,   E_to,   E_npts,   E_area,   E_edge_length,   E_pcs_merge,   E_w,   E_perimeter_merge,   E_score_size,   E_dscore,   d_mu,   d_sig,   iter_max,   agg_mode,   dscore_thresh,   min_npts,   max_npts )"},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs_cpp","text":"V_pcs, V_area, V_perimeter, V_npts Metadata associated tile. (Updated) E_from, E_to Length num_edges vectors associated pair adjacent tiles. Specifies two tiles border (0-indexed). (Updated) E_npts, E_area, E_edge_length, E_pcs_merge Metadata associated pair adjacent tiles. (Updated) E_w, E_perimeter_merge, E_score_size, E_dscore Scores associated merging pair adjacent tiles. (Updated)","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/merge_aggs_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merges tiles using single-linkage agglomerative clustering — merge_aggs_cpp","text":"list orig_num_tiles vectors, disjoint sets specifying IDs original tiles merged together. vectors length 0.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/normalize_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-normalization for counts data — normalize_data","title":"Log-normalization for counts data — normalize_data","text":"Normalizes cells total counts computes log(1+x) transform.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/normalize_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-normalization for counts data — normalize_data","text":"","code":"normalize_data(A, scaling_factor = NULL)"},{"path":"https://korsunskylab.github.io/tessera/reference/normalize_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-normalization for counts data — normalize_data","text":"genes x cells counts matrix. Must convertible dgCMatrix. scaling_factor Number total counts normalize cells . NULL, median counts across cells used. Defaults NULL.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/normalize_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-normalization for counts data — normalize_data","text":"Normalized genes x cells matrix dgCMatrix sparse matrix format.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://korsunskylab.github.io/tessera/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/prune_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Prunes mesh by eliminating long edges and small connected components — prune_graph","title":"Prunes mesh by eliminating long edges and small connected components — prune_graph","text":"Pruning works three steps: triangle edge longer threshold length removed. Afterwards, edge longer belongs triangle removed. point longer belongs edge removed. Connected components triangles shared edge computed. everything connected, nothing pruned. Otherwise, components (corresponding triangles) contain less mincells points removed. Afterwards, edge longer belongs triangle removed. point longer belongs edge removed.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/prune_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prunes mesh by eliminating long edges and small connected components — prune_graph","text":"","code":"prune_graph(data, thresh_quantile = 0.95, mincells = 10, thresh = NA)"},{"path":"https://korsunskylab.github.io/tessera/reference/prune_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prunes mesh by eliminating long edges and small connected components — prune_graph","text":"data list containing mesh data structures: pts V--M data table columns X Y containing coordinates cells additional metadata. tris F--4 data table containing X,Y coordinates triangle's centroid first two columns, area largest height triangle last two columns. edges E--14 data table columns from_pt, to_pt, from_tri, to_tri, x0_pt, x1_pt, y0_pt, y1_pt, x0_tri, x1_tri, y0_tri, y1_tri, length_pt, length_tri. one triangle uses edge, from_tri, x0_tri, y0_tri fields contain NaN values. tri_to_pt F--V sparse matrix value 1 (,j) triangle uses point j vertex. thresh_quantile Floating point value 0 1, inclusive. Quantile edge length edges pruned. Defaults 0.95. mincells Minimum number cells required connected component triangles kept. Defaults 10. thresh Edge length edges pruned. equal NA, value ignored thresh_quantile used compute threshold. Otherwise, thresh set, thresh_quantile ignored. Defaults NA.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/prune_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prunes mesh by eliminating long edges and small connected components — prune_graph","text":"list containing mesh data structures (possibly) fewer points, edges, triangles. Indices updated since objects might removed.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scaleRows_dgc.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-score a sparse matrix across each row — scaleRows_dgc","title":"Z-score a sparse matrix across each row — scaleRows_dgc","text":"Z-score sparse matrix across row","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scaleRows_dgc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-score a sparse matrix across each row — scaleRows_dgc","text":"","code":"scaleRows_dgc(x, p, i, ncol, nrow, thresh)"},{"path":"https://korsunskylab.github.io/tessera/reference/scaleRows_dgc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-score a sparse matrix across each row — scaleRows_dgc","text":"x, p, Internal data structures sparse matrix dgCMatrix format. ncol, nrow Dimensions sparse matrix input. thresh Z-scores thresh -thresh clipped thresh -thresh, respectively.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scaleRows_dgc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-score a sparse matrix across each row — scaleRows_dgc","text":"dense matrix column-major ordering dimensions nrow x ncol.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scale_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-score a sparse matrix across each row or column — scale_data","title":"Z-score a sparse matrix across each row or column — scale_data","text":"Z-score sparse matrix across row column","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scale_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-score a sparse matrix across each row or column — scale_data","text":"","code":"scale_data(A, margin = 1, thresh = 10)"},{"path":"https://korsunskylab.github.io/tessera/reference/scale_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-score a sparse matrix across each row or column — scale_data","text":"log-transformed genes x cells counts matrix. Must convertible dgCMatrix. margin Subscript compute Z-score. 1, row Z-scored; otherwise, column Z-scored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/scale_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Z-score a sparse matrix across each row or column — scale_data","text":"Z-scored genes x cells matrix dgCMatrix sparse matrix format.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field.html","id":null,"dir":"Reference","previous_headings":"","what":"Bilateral / anisotropic filtering of gradient field — smooth_field","title":"Bilateral / anisotropic filtering of gradient field — smooth_field","text":"Gradient fields smoothed using bilateral filtering, smoothed gradient point computed weighted average neighbors' gradients, considering distance space also similarity gradients.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bilateral / anisotropic filtering of gradient field — smooth_field","text":"","code":"smooth_field(   coords,   field,   adj,   include_self = TRUE,   distance = \"euclidean\",   similarity = \"euclidean\" )"},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bilateral / anisotropic filtering of gradient field — smooth_field","text":"coords N x 2 matrix cell coordinates. field 2 x D x N array column-major ordering containing spatial gradient expression D latent variables every point space. adj N x N sparse adjacency matrix dgCMatrix format. include_self boolean whether include point's gradient smoothed value. Defaults TRUE. distance Method computing distance score weighted average. See description details. Defaults 'euclidean'. similarity Method computing similarity score weighted average. See description details. Defaults 'euclidean'.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bilateral / anisotropic filtering of gradient field — smooth_field","text":"2 x D x N array column-major ordering containing smoothed spatial gradient expression D latent variables every point space.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bilateral / anisotropic filtering of gradient field — smooth_field","text":"weight neighbor computed product two scores: distance score: Generally, closer neighbors greater weight. 'euclidean': Gaussian transformation Euclidean distance cell neighbor, distant neighbors less weight. 'projected': anisotropic filter accounts expected change expression along direction neighbor. expected change expression calculated gradient field total derivative direction neighbor. change expression Gaussian transformed neighbors distant along direction greatest change less weight. 'constant': neighbors equal distance weights similarity score: Generally, neighbors similar gradients greater weight 'euclidean': Gaussian transformation Euclidean distance cell's gradient field neighbor's gradient field. 'projected': Gaussian transformation cosine distance cell's gradient field neighbor's gradient field. 'constant': neighbors equal similarity weights","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Bilateral / anisotropic filtering of gradient field — smooth_field_cpp","title":"Bilateral / anisotropic filtering of gradient field — smooth_field_cpp","text":"Gradient fields smoothed using bilateral filtering, smoothed gradient point computed weighted average neighbors' gradients, considering distance space also similarity gradients.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bilateral / anisotropic filtering of gradient field — smooth_field_cpp","text":"","code":"smooth_field_cpp(pvec, adj_i, adj_p, field, coords, distance, similarity)"},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bilateral / anisotropic filtering of gradient field — smooth_field_cpp","text":"pvec, adj_i, adj_p N x N sparse adjacency matrix dgCMatrix format: pvec = diff(adj@p), adj_i = adj@, adj_p = adj@p field 2 x D x N array column-major ordering containing spatial gradient expression D latent variables every point space. coords N x 2 matrix cell coordinates. distance Method computing distance score weighted average. See description details. Defaults 'euclidean'. similarity Method computing similarity score weighted average. See description details. Defaults 'euclidean'.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/smooth_field_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bilateral / anisotropic filtering of gradient field — smooth_field_cpp","text":"2 x D x N array column-major ordering containing smoothed spatial gradient expression D latent variables every point space.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/tessera.html","id":null,"dir":"Reference","previous_headings":"","what":"Accurate tiling of spatial single-cell data — tessera","title":"Accurate tiling of spatial single-cell data — tessera","text":"algorithm segmenting single-cell resolution spatial omics data small multicellular tiles whose edges track natural tissue boundaries. tiles can used downstream analysis label define tissue regions across samples.","code":""},{"path":[]},{"path":"https://korsunskylab.github.io/tessera/reference/tessera.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Accurate tiling of spatial single-cell data — tessera","text":"Maintainer: Ilya Korsunsky ilya.korsunsky@gmail.com (ORCID) Authors: Daniel Stein daniel_stein@g.harvard.edu (ORCID)","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/tessera_warmup.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data for Tessera vignettes — tessera_warmup","title":"Sample data for Tessera vignettes — tessera_warmup","text":"Subset MERFISH lung cancer dataset (Chen et al 2024).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/tessera_warmup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data for Tessera vignettes — tessera_warmup","text":"","code":"tessera_warmup"},{"path":"https://korsunskylab.github.io/tessera/reference/tessera_warmup.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data for Tessera vignettes — tessera_warmup","text":"counts meta data table 3177 cells. counts dgCMatrix gene--cell counts meta_data data.frame spatial locations (XY) cell lineage (type)","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/tessera_warmup.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data for Tessera vignettes — tessera_warmup","text":"Chen, J.H., Nieman, L.T., Spurrell, M. et al. Human lung cancer harbors spatially organized stem-immunity hubs associated response immunotherapy. Nat Immunol 25, 644–658 (2024). https://doi.org/10.1038/s41590-024-01792-2","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_back_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace back from a point to its root in the spanning forest — trace_back_cpp","title":"Trace back from a point to its root in the spanning forest — trace_back_cpp","text":"Trace back point root spanning forest","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_back_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace back from a point to its root in the spanning forest — trace_back_cpp","text":"","code":"trace_back_cpp(v0, vcrit, parent_edge, parent)"},{"path":"https://korsunskylab.github.io/tessera/reference/trace_back_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace back from a point to its root in the spanning forest — trace_back_cpp","text":"v0 Index starting point (0-indexed). vcrit Index critical point associated tree v0 belongs (0-indexed). parent_edge length num_points vector containing directed edge point target node. Critical points parent edge, value ignored. parent length num_points vector containing parent (source) point point directed spanning forest. Critical points parent, value ignored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_back_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace back from a point to its root in the spanning forest — trace_back_cpp","text":"Vector edge indices along path v0 root vcrit tree (1-indexed).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_epaths_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace all paths from saddles to critical points in the spanning forest — trace_epaths_cpp","title":"Trace all paths from saddles to critical points in the spanning forest — trace_epaths_cpp","text":"Trace paths saddles critical points spanning forest","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_epaths_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace all paths from saddles to critical points in the spanning forest — trace_epaths_cpp","text":"","code":"trace_epaths_cpp(saddles, vcrits, edges_from, edges_to, parent_edge, parent)"},{"path":"https://korsunskylab.github.io/tessera/reference/trace_epaths_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace all paths from saddles to critical points in the spanning forest — trace_epaths_cpp","text":"saddles length num_saddles vector edge indices saddle edges (0-indexed). vcrits length num_critpts vector critical points. edges_from length num_edges vector indices first end-point edge mesh (0-indexed). edges_to length num_edges vector indices second end-point edge mesh (0-indexed). parent_edge length num_points vector containing directed edge point target node directed spanning forest. Critical points parent edge, value ignored. parent length num_points vector containing parent (source) point point directed spanning forest. Critical points parent, value ignored.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_epaths_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace all paths from saddles to critical points in the spanning forest — trace_epaths_cpp","text":"list length 2*num_saddles containing two paths saddle edge two critical points joins. path numeric vector edge indices (1-indexed).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace all paths from saddles to dual critical points in the spanning forest. — trace_paths","title":"Trace all paths from saddles to dual critical points in the spanning forest. — trace_paths","text":"dual spanning forest maximum spanning forest triangles mesh, paths traced saddles critical triangles (maxima) follow ridges, separating points components strongest boundaries.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace all paths from saddles to dual critical points in the spanning forest. — trace_paths","text":"","code":"trace_paths(dmt, dual, saddles)"},{"path":"https://korsunskylab.github.io/tessera/reference/trace_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace all paths from saddles to dual critical points in the spanning forest. — trace_paths","text":"dmt DMT data structure following attributes: edges$from_tri: Index first triangle joined edge (1-indexed). edges$to_tri: Index second triangle joined edge (1-indexed). dual dual maximum spanning forest triangles: labels: length num_triangles vector labels connected components maximum spanning tree. connected component labeled index critical triangle. parent: length num_triangles vector containing parent (source) triangle triangle directed spanning forest. Critical triangles parent, value ignored. parent_edge: length num_triangles vector containing directed edge triangle target node. Critical triangles parent edge, value ignored. saddles length num_saddles vector edge indices saddle edges (1-indexed).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace all paths from saddles to dual critical points in the spanning forest. — trace_paths","text":"list length 2*num_saddles containing two paths saddle edge two critical points joins. path numeric vector edge indices (1-indexed).","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons.html","id":null,"dir":"Reference","previous_headings":"","what":"Contruct shapes that outline each tile — trace_polygons","title":"Contruct shapes that outline each tile — trace_polygons","text":"Contruct shapes outline tile","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contruct shapes that outline each tile — trace_polygons","text":"","code":"trace_polygons(dmt, aggs)"},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contruct shapes that outline each tile — trace_polygons","text":"dmt DMT mesh data structure pts, edges, tris attributes. Assignment points tiles provided dmt$pts$agg_id. aggs tile data structure used specify total number tiles.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contruct shapes that outline each tile — trace_polygons","text":"sfc list-column geometries tile.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Contruct shapes that outline each tile — trace_polygons_cpp","title":"Contruct shapes that outline each tile — trace_polygons_cpp","text":"Contruct shapes outline tile","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contruct shapes that outline each tile — trace_polygons_cpp","text":"","code":"trace_polygons_cpp(edges, naggs, ntris, pts_dmt_component)"},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contruct shapes that outline each tile — trace_polygons_cpp","text":"edges matrix num_edges rows mesh edge information. naggs Number tiles. pts_dmt_component length num_points vector unique ID tile point belongs . ntrix Number triangles mesh.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/trace_polygons_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contruct shapes that outline each tile — trace_polygons_cpp","text":"list length naggs matrices contain coordinates polygons trace outline tile.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_E_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Updates information for boundaries after merging two tiles — update_E_cpp","title":"Updates information for boundaries after merging two tiles — update_E_cpp","text":"every boundary exists new merged tile tiles, following values must updated: E_pcs_merge[e_update,]: PCs result future merging. E_perimeter_merge[e_update]: Perimeters result future merging. E_w[e_update]: Expression similarity score. E_score_size[e_update]: Size merged tile score. dC[e_update]: Delta shape compactness score merged tile. E_dscore[e_update]: Overall merging score (product w, score_size, dC) Note E_npts E_area already previously updated.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_E_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updates information for boundaries after merging two tiles — update_E_cpp","text":"","code":"update_E_cpp(   V_pcs,   V_perimeter,   V_area,   V_npts,   E_from,   E_to,   E_npts,   E_area,   E_edge_length,   E_pcs_merge,   E_w,   E_perimeter_merge,   E_score_size,   E_dscore,   e_update,   V_to_E_from,   V_to_E_to,   d_mu,   d_sig,   agg_mode,   min_npts,   max_npts )"},{"path":"https://korsunskylab.github.io/tessera/reference/update_E_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updates information for boundaries after merging two tiles — update_E_cpp","text":"e_update Edges updated.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_V_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Updates information for tiles after merging two tiles — update_V_cpp","title":"Updates information for tiles after merging two tiles — update_V_cpp","text":"Uses information shared edge update merged PCs, area, number points, perimeter. Mutates e_merge_fromth value within V_pcs, V_npts, V_perimeter, V_area input data structures.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_V_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updates information for tiles after merging two tiles — update_V_cpp","text":"","code":"update_V_cpp(   V_pcs,   V_npts,   V_perimeter,   V_area,   e_merge_from,   e_merge_to,   e_merge_edge_length,   e_merge_area,   e_merge_npts,   e_merge_pcs,   agg_mode )"},{"path":"https://korsunskylab.github.io/tessera/reference/update_agg_shapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Update shapes and counts matrix for tiles after merging — update_agg_shapes","title":"Update shapes and counts matrix for tiles after merging — update_agg_shapes","text":"Update shapes counts matrix tiles merging","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_agg_shapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update shapes and counts matrix for tiles after merging — update_agg_shapes","text":"","code":"update_agg_shapes(dmt, aggs)"},{"path":"https://korsunskylab.github.io/tessera/reference/update_agg_shapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update shapes and counts matrix for tiles after merging — update_agg_shapes","text":"dmt DMT data structure agg Tile data structure merging","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_agg_shapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update shapes and counts matrix for tiles after merging — update_agg_shapes","text":"aggs tile data structure updated values : meta_data$shape Retraces polygons tiles using new point assignments. meta_data$X,meta_data$Y Recomputes centroid tile polygon shape. edges Ensures aggs$edges always < . counts num_genes x num_tiles gene--tile matrix aggregated transcript counts.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_dmt_aggid.html","id":null,"dir":"Reference","previous_headings":"","what":"Update tile IDs in the DMT data structure after merging — update_dmt_aggid","title":"Update tile IDs in the DMT data structure after merging — update_dmt_aggid","text":"Update tile IDs DMT data structure merging","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_dmt_aggid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update tile IDs in the DMT data structure after merging — update_dmt_aggid","text":"","code":"update_dmt_aggid(dmt, aggs)"},{"path":"https://korsunskylab.github.io/tessera/reference/update_dmt_aggid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update tile IDs in the DMT data structure after merging — update_dmt_aggid","text":"dmt DMT data structure agg Tile data structure merging, aggmap attribute mapping original tile IDs new IDs merged tiles.","code":""},{"path":"https://korsunskylab.github.io/tessera/reference/update_dmt_aggid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update tile IDs in the DMT data structure after merging — update_dmt_aggid","text":"DMT data structure updated values attributes: pts$agg_id: Unique ID tile point belongs . edges$agg_from: Unique ID tile edges$from_pt belongs . edges$agg_to: Unique ID tile edges$to_pt belongs .","code":""}]
