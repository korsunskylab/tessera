# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Z-score a sparse matrix across each row
#'
#' @param x,p,i Internal data structures from a
#'   sparse matrix in dgCMatrix format.
#' @param ncol,nrow Dimensions of sparse matrix input.
#' @param thresh Z-scores above `thresh` and below
#'   `-thresh` are clipped to `thresh` and `-thresh`,
#'   respectively.
#'
#' @returns A dense matrix in column-major ordering
#'   with dimensions `nrow` x `ncol`.
scaleRows_dgc <- function(x, p, i, ncol, nrow, thresh) {
    .Call('_cygnus_scaleRows_dgc', PACKAGE = 'cygnus', x, p, i, ncol, nrow, thresh)
}

st_mats_perimeter <- function(Xvec) {
    .Call('_cygnus_st_mats_perimeter', PACKAGE = 'cygnus', Xvec)
}

get_e_minus_epaths_saddles <- function(epaths, saddles, N) {
    .Call('_cygnus_get_e_minus_epaths_saddles', PACKAGE = 'cygnus', epaths, saddles, N)
}

is_in_list <- function(target, mylist) {
    .Call('_cygnus_is_in_list', PACKAGE = 'cygnus', target, mylist)
}

#' Copies elements from two lists an Armadillo uvec
#'
#' Concatenates the values from `list1` and `list2`.
#'
#' @param list1,list2 Lists of unsigned values.
#'
#' @returns An Armadillo uvec that concatenates `list1` and `list2`.
mergeListsToArmaUVec <- function(list1, list2) {
    .Call('_cygnus_mergeListsToArmaUVec', PACKAGE = 'cygnus', list1, list2)
}

#' Find duplicates within a vector
#'
#' @param input Vector of values.
#' 
#' @returns Vector of values from `input` that appear at least twice.
#'   Each value that appears N times in `input` will appear N-1 times in the output.
findDuplicates <- function(input) {
    .Call('_cygnus_findDuplicates', PACKAGE = 'cygnus', input)
}

#' Updates information for tiles after merging two tiles
#'
#' Uses the information from the shared edge to update the merged PCs,
#' area, number of points, and perimeter. Mutates the `e_merge_from`th value
#' within the `V_pcs`, `V_npts`, `V_perimeter`, `V_area` input data structures.
#'
update_V_cpp <- function(V_pcs, V_npts, V_perimeter, V_area, e_merge_from, e_merge_to, e_merge_edge_length, e_merge_area, e_merge_npts, e_merge_pcs, agg_mode) {
    invisible(.Call('_cygnus_update_V_cpp', PACKAGE = 'cygnus', V_pcs, V_npts, V_perimeter, V_area, e_merge_from, e_merge_to, e_merge_edge_length, e_merge_area, e_merge_npts, e_merge_pcs, agg_mode))
}

#' Updates information for boundaries after merging two tiles
#'
#' For every boundary that exists between the new merged tile and other tiles,
#' the following values must be updated:
#'  * `E_pcs_merge[e_update,]`: PCs that would result from future merging.
#'  * `E_perimeter_merge[e_update]`: Perimeters that would result from future merging.
#'  * `E_w[e_update]`: Expression similarity score.
#'  * `E_score_size[e_update]`: Size of merged tile score.
#'  * `dC[e_update]`: Delta shape compactness score for merged tile.
#'  * `E_dscore[e_update]`: Overall merging score (product of `w`, `score_size`, `dC`)
#' Note that `E_npts` and `E_area` should already have been previously updated.
#'
#' @param e_update Edges that should be updated.
update_E_cpp <- function(V_pcs, V_perimeter, V_area, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, e_update, V_to_E_from, V_to_E_to, d_mu, d_sig, agg_mode, min_npts, max_npts) {
    invisible(.Call('_cygnus_update_E_cpp', PACKAGE = 'cygnus', V_pcs, V_perimeter, V_area, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, e_update, V_to_E_from, V_to_E_to, d_mu, d_sig, agg_mode, min_npts, max_npts))
}

#' Merges tiles using single-linkage agglomerative clustering
#'
#' Note that this function mutates many of the inputs to keep
#' track of updated values for tiles and their borders after
#' each successive merge. Every merge of adjacent tiles has an
#' associated score (higher means merging is more favorable).
#' Merging is conducted greedily, one step of a time, updating
#' the score associated with pair of tiles at each step. 
#'
#' @param V_pcs,V_area,V_perimeter,V_npts Metadata associated with each each tile.
#'   (Updated)
#' @param E_from,E_to Length `num_edges` vectors associated with each pair of
#'   adjacent tiles. Specifies the two tiles that each border (0-indexed). (Updated)
#' @param E_npts,E_area,E_edge_length,E_pcs_merge Metadata associated with each pair of
#'   adjacent tiles. (Updated)
#' @param E_w,E_perimeter_merge,E_score_size,E_dscore Scores associated with merging
#'   each pair of adjacent tiles. (Updated)
#'
#' @returns A list of `orig_num_tiles` vectors, disjoint sets specifying the IDs for which
#'   of the original tiles have been merged together. Some vectors will have length 0.
#'
merge_aggs_cpp <- function(V_pcs, V_area, V_perimeter, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, d_mu, d_sig, iter_max, agg_mode, dscore_thresh, min_npts, max_npts) {
    .Call('_cygnus_merge_aggs_cpp', PACKAGE = 'cygnus', V_pcs, V_area, V_perimeter, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, d_mu, d_sig, iter_max, agg_mode, dscore_thresh, min_npts, max_npts)
}

foo_triplets_edges <- function(triplets, edges) {
    .Call('_cygnus_foo_triplets_edges', PACKAGE = 'cygnus', triplets, edges)
}

#' Construct maximum spanning forest
#'
#' Constructs a directed maximum spanning forest from point and edge scalar values
#' using a version of Prim's algorithm. Critical points (local maxima; or, more precisely,
#' an endpoint of an edge that is a local maxima) are used as roots for each tree in the
#' forest, and edges that would bridge two trees with different critical point roots are
#' marked as possible saddle edges.
#'
#' @param f Vector of `num_points` scalar values defined at each point.
#' @param edges_from Vector of `num_edges` indices for first end-point of each edge (0-indexed).
#' @param edges_to Vector of `num_edges` indices for second end-point of each edge (0-indexed).
#' @param edges_f Vector of `num_edges` scalar values defined along each edge.
#'
#' @returns A List with the following attributes (all indices are 1-indexed):
#'  * `edges`: A `forest_size` x `2` matrix where each row is a directed edge
#'    in the maximum spanning forest. The first column has the source point for
#'    each edge and the second column has the target point.
#'  * `saddles`: A length `num_saddles` vector with edge indices for possible saddle edges.
#'  * `labels`: A length `num_points` vector of labels for the connected components in the
#'    maximum spanning tree. Each connected component is labeled by the index of its critical point.
#'  * `critpts`: A length `num_critpts` vector of critical points (maxima).
#'  * `parent`: A length `num_points` vector containing the parent (source) point for each
#'    point in the directed spanning forest. Critical points have no parent, so the value should be ignored.
#'  * `parent_edge`: A length `num_points` vector containing the directed edge that has
#'    each point as a target node. Critical points have no parent edge, so the value should be ignored.
#'
do_dmt_forest_cpp <- function(f, edges_from, edges_to, edges_f) {
    .Call('_cygnus_do_dmt_forest_cpp', PACKAGE = 'cygnus', f, edges_from, edges_to, edges_f)
}

#' Trace back from a point to its root in the spanning forest
#'
#' @param v0 Index of starting point (0-indexed).
#' @param vcrit Index of critical point associated with the tree that `v0` belongs to (0-indexed).
#' @param parent_edge A length `num_points` vector containing the directed edge that has
#'    each point as a target node. Critical points have no parent edge, so the value is ignored.
#' @param parent A length `num_points` vector containing the parent (source) point for each
#'    point in the directed spanning forest. Critical points have no parent, so the value is ignored.
#'
#' @returns Vector of edge indices along the path from `v0` to its root `vcrit` in the tree (1-indexed).
#'
trace_back_cpp <- function(v0, vcrit, parent_edge, parent) {
    .Call('_cygnus_trace_back_cpp', PACKAGE = 'cygnus', v0, vcrit, parent_edge, parent)
}

#' Trace all paths from saddles to critical points in the spanning forest
#'
#' @param saddles A length `num_saddles` vector with edge indices for saddle edges (0-indexed).
#' @param vcrits A length `num_critpts` vector of critical points.
#' @param edges_from A length `num_edges` vector with indices for the first end-point of each edge
#'   in the mesh (0-indexed).
#' @param edges_to A length `num_edges` vector with indices for the second end-point of each edge
#'   in the mesh (0-indexed).
#' @param parent_edge A length `num_points` vector containing the directed edge that has
#'    each point as a target node in the directed spanning forest. Critical points have
#'    no parent edge, so the value is ignored.
#' @param parent A length `num_points` vector containing the parent (source) point for each
#'    point in the directed spanning forest. Critical points have no parent, so the value is ignored.
#'
#' @returns A list of length `2*num_saddles` containing the two paths from each saddle edge to the
#'   two critical points that it joins. Each path is a numeric vector of edge indices (1-indexed).
trace_epaths_cpp <- function(saddles, vcrits, edges_from, edges_to, parent_edge, parent) {
    .Call('_cygnus_trace_epaths_cpp', PACKAGE = 'cygnus', saddles, vcrits, edges_from, edges_to, parent_edge, parent)
}

#' Get the collection of edges that lie along separatrices
#'
#' @param epaths A list of length `2*num_saddles` containing the two paths from each saddle edge to the
#'   two critical points that it joins. Each path is a numeric vector of edge indices (1-indexed).
#' @param saddles A length `num_saddles` vector with edge indices for saddle edges (1-indexed).
#' @param nedges Total number of edges in the mesh.
#'
#' @returns A length `num_sep_edges` vector of edges (0-indexed) that are saddle edges in `saddles` or
#'   lie along the paths in `epaths`. These edges make up the separatrices that separate points into
#'   different components.
get_e_sep <- function(epaths, saddles, nedges) {
    .Call('_cygnus_get_e_sep', PACKAGE = 'cygnus', epaths, saddles, nedges)
}

prune_e_sep <- function(edges, ntris, is_tri_external, e_sep) {
    .Call('_cygnus_prune_e_sep', PACKAGE = 'cygnus', edges, ntris, is_tri_external, e_sep)
}

#' Bilateral / anisotropic filtering of gradient field
#' 
#' Gradient fields are smoothed using bilateral filtering,
#' in which the smoothed gradient of each point is computed as
#' the weighted average of the neighbors' gradients, considering
#' both distance in space and also similarity in gradients.
#' 
#' @param pvec,adj_i,adj_p A `N` x `N` sparse adjacency matrix
#'   in dgCMatrix format: `pvec = diff(adj@p)`, `adj_i = adj@i`,
#'   and `adj_p = adj@p`
#' @param field A `2` x `D` x `N` array in column-major ordering
#'   containing the spatial gradient in expression for each of
#'   `D` latent variables at every point in space.
#' @param coords A `N` x `2` matrix of cell coordinates.
#' @param distance Method for computing distance score in weighted average.
#'   See description for details. Defaults to `'euclidean'`.
#' @param similarity Method for computing similarity score in weighted average.
#'   See description for details. Defaults to `'euclidean'`.
#' 
#' @returns A `2` x `D` x `N` array in column-major ordering
#'   containing the smoothed spatial gradient in expression for each of
#'   `D` latent variables at every point in space.
#' 
smooth_field_cpp <- function(pvec, adj_i, adj_p, field, coords, distance, similarity) {
    .Call('_cygnus_smooth_field_cpp', PACKAGE = 'cygnus', pvec, adj_i, adj_p, field, coords, distance, similarity)
}

#' Compress a gradient field using SVD
#'
#' Expresses the `2` x `D` total derivative at each location as
#' a pair of `2`-dimensional vectors in the gradient and orthogonal
#' directions.
#'
#' @param field A `2` x `D` x `N` array in column-major ordering
#'   containing the spatial gradient in expression for each of
#'   `D` latent variables at every point, edge, or triangle.
#'
#' @returns A `N` x `6` matrix with the following attributes for
#'   each location:
#'   \item{dx grad,dy grad}{x,y directions of unit vector in the
#'     direction of greatest change (first singular vector).}
#'   \item{dx ortho,dy ortho}{x,y directions of unit vector orthogonal
#'     to the direction of greatest change (second singular vector).}
#'   \item{|grad|,|ortho|}{Magnitude of directional derivative in the
#'     gradient and orthogonal directions (singular values).}
#'
compress_field_cpp <- function(field) {
    .Call('_cygnus_compress_field_cpp', PACKAGE = 'cygnus', field)
}

#' Compute a spatial gradient field at each point (cell)
#'
#' Distance between neighboring cells is normalized to unit distance
#' so that only the direction from each cell to its neighbors matters.
#' The gradient is then the average gradient in expression of each
#' embedding dimension between the index cell and its neighbors.
#'
#' @param coords A `N` x `2` matrix of cell coordinates.
#' @param embeddings A `N` x `D` matrix of cell embeddings.
#' @param adj_i,adj_p A `N` x `N` sparse adjacency matrix
#'   in dgCMatrix format.
#'
#' @returns A `2` x `D` x `N` array in column-major ordering
#'   containing the spatial gradient in expression for each of
#'   `D` embedding dimensions at every point in space.
#'
estimate_field_cpp <- function(coords, embeddings, adj_i, adj_p) {
    .Call('_cygnus_estimate_field_cpp', PACKAGE = 'cygnus', coords, embeddings, adj_i, adj_p)
}

#' Assigns a unique ID to each point with distinct X,Y coordinates
#'
#' @param X,Y A pair of numeric vectors with the coordinates for each point.
#'
#' @returns A vector with the same length as `X` and `Y` containing
#'   IDs that range from 0 to N where N is the number of unique points.
#' 
assign_unique_rowid_cpp <- function(X, Y) {
    .Call('_cygnus_assign_unique_rowid_cpp', PACKAGE = 'cygnus', X, Y)
}

#' Calculates triangles' centroids, areas, and heights from vertices
#'
#' @param triplets A M-by-3 matrix with indices for the points that
#'   correspond each triangle's vertices, where M is the number of triangles.
#' @param pts A N-by-2 matrix with indices for the X,Y coordinates of
#'   each point.
#' @param tris A M-by-4 matrix containing the X,Y coordinates of each
#'   triangle's centroid in the first two columns, and area and
#'   largest height of each triangle in the last two columns.
#'
#' @returns A E-by-14 matrix with columns `from_pt`, `to_pt`, `from_tri`, `to_tri`,
#'   `x0_pt`, `x1_pt`, `y0_pt`, `y1_pt`, `x0_tri`, `x1_tri`, `y0_tri`, `y1_tri`,
#'   `length_pt`, `length_tri`. If only one triangle uses an edge, then the `from_tri`,
#'   `x0_tri`, and `y0_tri` fields will contain NaN values.
#'
#'   Note that indices that reference the `pts` and `tris` tables are 1-indexed.
#' 
init_edges_cpp <- function(triplets, pts, tris) {
    .Call('_cygnus_init_edges_cpp', PACKAGE = 'cygnus', triplets, pts, tris)
}

#' Calculates triangles' centroids, areas, and heights from vertices
#'
#' @param triplets A M-by-3 matrix with indices for the points that
#'   correspond each triangle's vertices, where M is the number of triangles.
#' @param pts A N-by-2 matrix with indices for the X,Y coordinates of
#'   each point.
#' 
#' @returns A M-by-4 matrix containing the X,Y coordinates of each
#'   triangle's centroid in the first two columns, and area and
#'   largest height of each triangle in the last two columns.
#' 
init_tris_cpp <- function(triplets, pts) {
    .Call('_cygnus_init_tris_cpp', PACKAGE = 'cygnus', triplets, pts)
}

mapToConsecutivePositions <- function(numbers) {
    .Call('_cygnus_mapToConsecutivePositions', PACKAGE = 'cygnus', numbers)
}

splitSequence <- function(y) {
    .Call('_cygnus_splitSequence', PACKAGE = 'cygnus', y)
}

findLargestComponentEulerCycle <- function(edges) {
    .Call('_cygnus_findLargestComponentEulerCycle', PACKAGE = 'cygnus', edges)
}

get_agg_to_boundary_edge <- function(E, n_agg) {
    .Call('_cygnus_get_agg_to_boundary_edge', PACKAGE = 'cygnus', E, n_agg)
}

get_agg_to_edge <- function(edges, naggs, always_include_boundary) {
    .Call('_cygnus_get_agg_to_edge', PACKAGE = 'cygnus', edges, naggs, always_include_boundary)
}

get_boundary_graph_cpp <- function(e_dual, i_pts, e_prim, E, ntris) {
    .Call('_cygnus_get_boundary_graph_cpp', PACKAGE = 'cygnus', e_dual, i_pts, e_prim, E, ntris)
}

#' Contruct shapes that outline each tile
#'
#' @param edges A matrix with `num_edges` rows with mesh edge information.
#' @param naggs Number of tiles.
#' @param ntrix Number of triangles in the mesh.
#' @pts_dmt_component A length `num_points` vector with the unique ID for the
#'   tile that each point belongs to.
#'
#' @returns A list of length `naggs` matrices that contain coordinates of the
#'   polygons that trace the outline of each tile.
#'
trace_polygons_cpp <- function(edges, naggs, ntris, pts_dmt_component) {
    .Call('_cygnus_trace_polygons_cpp', PACKAGE = 'cygnus', edges, naggs, ntris, pts_dmt_component)
}

trace_polygons_pts_cpp <- function(edges, naggs) {
    .Call('_cygnus_trace_polygons_pts_cpp', PACKAGE = 'cygnus', edges, naggs)
}

